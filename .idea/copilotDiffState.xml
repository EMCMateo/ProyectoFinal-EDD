<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="updatedContent" value="&lt;!-- ...existing code... --&gt;&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;org.jfree&lt;/groupId&gt;&#10;    &lt;artifactId&gt;jfreechart&lt;/artifactId&gt;&#10;    &lt;version&gt;1.5.3&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;&lt;!-- ...existing code... --&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/controlador/CSVLogger.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/controlador/CSVLogger.java" />
              <option name="originalContent" value="// /src/main/java/util/CSVLogger.java&#10;package util;&#10;&#10;import java.io.File;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.io.PrintWriter;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.Locale;&#10;&#10;/**&#10; * Una clase de utilidad para registrar los resultados de la ejecución&#10; * de los algoritmos en un archivo CSV.&#10; *&#10; * @author Einar Kaalhus&#10; * @version 1.0&#10; */&#10;public class CSVLogger {&#10;    private final String filePath;&#10;    private static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);&#10;    private static final String CSV_HEADER = &quot;Timestamp,Algorithm,PathFound,PathLength,ExecutionTime(ms)&quot;;&#10;&#10;    public CSVLogger(String filePath) {&#10;        this.filePath = filePath;&#10;        initFile();&#10;    }&#10;&#10;    /**&#10;     * Crea el archivo CSV con su encabezado si no existe.&#10;     */&#10;    private void initFile() {&#10;        File file = new File(filePath);&#10;        if (!file.exists()) {&#10;            try (PrintWriter writer = new PrintWriter(new FileWriter(filePath))) {&#10;                writer.println(CSV_HEADER);&#10;            } catch (IOException e) {&#10;                System.err.println(&quot;Error al inicializar el archivo CSV: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Añade una nueva fila de resultados al archivo CSV.&#10;     *&#10;     * @param algorithm El nombre del algoritmo usado.&#10;     * @param success   Si se encontró una ruta o no.&#10;     * @param pathLength La longitud de la ruta (0 si no se encontró).&#10;     * @param timeMs    El tiempo de ejecución en milisegundos.&#10;     */&#10;    public void logResult(String algorithm, boolean success, int pathLength, double timeMs) {&#10;        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, true))) {&#10;            String timestamp = dtf.format(LocalDateTime.now());&#10;            // Usamos Locale.US para asegurar que el punto decimal sea un punto.&#10;            String record = String.format(Locale.US, &quot;%s,%s,%b,%d,%.4f&quot;,&#10;                    timestamp,&#10;                    algorithm,&#10;                    success,&#10;                    pathLength,&#10;                    timeMs&#10;            );&#10;            writer.println(record);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error al escribir en el archivo CSV: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="// /src/main/java/util/CSVLogger.java&#10;package util;&#10;&#10;import java.io.File;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.io.PrintWriter;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.Locale;&#10;&#10;/**&#10; * Clase utilitaria para registrar los resultados de las ejecuciones de los algoritmos&#10; * en un archivo CSV. Mantiene un historial de todas las soluciones intentadas.&#10; *&#10; * Características:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Registra timestamp, algoritmo usado, éxito/fracaso y tiempo de ejecución&lt;/li&gt;&#10; *   &lt;li&gt;Crea el archivo si no existe y añade encabezados&lt;/li&gt;&#10; *   &lt;li&gt;Maneja escritura segura con manejo de recursos&lt;/li&gt;&#10; *   &lt;li&gt;Permite análisis posterior de rendimiento&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * El formato del CSV es:&#10; * Timestamp,Algorithm,PathFound,PathLength,ExecutionTime(ms)&#10; *&#10; * @author Israel Orellana&#10; * @version 1.0&#10; */&#10;public class CSVLogger {&#10;    private final String filePath;&#10;    private static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);&#10;    private static final String CSV_HEADER = &quot;Timestamp,Algorithm,PathFound,PathLength,ExecutionTime(ms)&quot;;&#10;&#10;    public CSVLogger(String filePath) {&#10;        this.filePath = filePath;&#10;        initFile();&#10;    }&#10;&#10;    /**&#10;     * Crea el archivo CSV con su encabezado si no existe.&#10;     */&#10;    private void initFile() {&#10;        File file = new File(filePath);&#10;        if (!file.exists()) {&#10;            try (PrintWriter writer = new PrintWriter(new FileWriter(filePath))) {&#10;                writer.println(CSV_HEADER);&#10;            } catch (IOException e) {&#10;                System.err.println(&quot;Error al inicializar el archivo CSV: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Añade una nueva fila de resultados al archivo CSV.&#10;     *&#10;     * @param algorithm El nombre del algoritmo usado.&#10;     * @param success   Si se encontró una ruta o no.&#10;     * @param pathLength La longitud de la ruta (0 si no se encontró).&#10;     * @param timeMs    El tiempo de ejecución en milisegundos.&#10;     */&#10;    public void logResult(String algorithm, boolean success, int pathLength, double timeMs) {&#10;        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, true))) {&#10;            String timestamp = dtf.format(LocalDateTime.now());&#10;            // Usamos Locale.US para asegurar que el punto decimal sea un punto.&#10;            String record = String.format(Locale.US, &quot;%s,%s,%b,%d,%.4f&quot;,&#10;                    timestamp,&#10;                    algorithm,&#10;                    success,&#10;                    pathLength,&#10;                    timeMs&#10;            );&#10;            writer.println(record);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error al escribir en el archivo CSV: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/controlador/Controller.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/controlador/Controller.java" />
              <option name="originalContent" value="// /src/main/java/controlador/Controller.java&#10;package controlador;&#10;&#10;import modelo.*;&#10;import vista.MazeView;&#10;import util.CSVLogger;&#10;&#10;import java.awt.Point;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * El controlador principal de la aplicación. Conecta la Vista (MazeView)&#10; * con el Modelo (los algoritmos de resolución de laberintos).&#10; *&#10; * @author Einar Kaalhus&#10; * @version 1.2 - Añadido manejo de estado para visualización completa y paso a paso.&#10; */&#10;public class Controller {&#10;    private final MazeView view;&#10;    private final CSVLogger csvLogger;&#10;&#10;    // --- NUEVO: Atributos para guardar el último resultado ---&#10;    private List&lt;int[]&gt; lastFinalPath;&#10;    private List&lt;int[]&gt; lastVisitedCells;&#10;&#10;    public Controller(MazeView view) {&#10;        this.view = view;&#10;        this.csvLogger = new CSVLogger(&quot;resultados_laberinto.csv&quot;);&#10;        this.lastFinalPath = null;&#10;        this.lastVisitedCells = null;&#10;        initController();&#10;    }&#10;&#10;    private void initController() {&#10;        view.getControlPanel().addGenerateListener(e -&gt; generateNewMaze());&#10;        view.getControlPanel().addSolveListener(e -&gt; solveMaze());&#10;        view.getControlPanel().addClearAllListener(e -&gt; clearAll());&#10;&#10;        // --- NUEVO: Listeners para los nuevos botones ---&#10;        view.getControlPanel().addShowFullPathListener(e -&gt; showFullPath());&#10;        view.getControlPanel().addStepByStepListener(e -&gt; showNextStep());&#10;&#10;        // Listeners existentes para reportes&#10;        view.addListResultsListener(e -&gt; view.showResultsTable());&#10;        view.addShowTimesChartListener(e -&gt; view.showTimesChart());&#10;    }&#10;&#10;    private void generateNewMaze() {&#10;        int rows = view.getControlPanel().getRows();&#10;        int cols = view.getControlPanel().getCols();&#10;        view.getMazePanel().setMazeData(new int[rows][cols]);&#10;        view.getMazePanel().clearMaze();&#10;        view.pack();&#10;        // Limpiar resultados al generar nuevo laberinto&#10;        lastFinalPath = null;&#10;        lastVisitedCells = null;&#10;    }&#10;&#10;    private void solveMaze() {&#10;        view.getMazePanel().clearVisuals(); // Limpia dibujos anteriores&#10;&#10;        int[][] mazeData = view.getMazePanel().getMazeData();&#10;        Point startPoint = view.getMazePanel().getStartPoint();&#10;        Point endPoint = view.getMazePanel().getEndPoint();&#10;        String algorithm = view.getControlPanel().getSelectedAlgorithm();&#10;&#10;        if (startPoint == null || endPoint == null) {&#10;            view.showError(&quot;Por favor, defina un punto de inicio y fin.&quot;);&#10;            return;&#10;        }&#10;        // ... (otras validaciones que ya tenías)&#10;&#10;        List&lt;int[]&gt; path;&#10;        List&lt;int[]&gt; visitedCells;&#10;&#10;        long startTime = System.nanoTime();&#10;&#10;        // --- Lógica de ejecución movida aquí ---&#10;        Laberinto laberinto = createLaberintoFromData(mazeData);&#10;        Celda inicio = laberinto.getCelda(startPoint.y, startPoint.x);&#10;        Celda fin = laberinto.getCelda(endPoint.y, endPoint.x);&#10;&#10;        switch (algorithm) {&#10;            case &quot;BFS&quot;:&#10;                SolverBFS bfs = new SolverBFS();&#10;                path = convertCeldaPathToIntArrayPath(bfs.buscarRuta(laberinto, inicio, fin));&#10;                visitedCells = convertCeldaPathToIntArrayPath(bfs.getRecorrido());&#10;                break;&#10;&#10;            case &quot;DFS&quot;:&#10;                SolverDFS dfs = new SolverDFS();&#10;                path = convertCeldaPathToIntArrayPath(dfs.buscarRuta(laberinto, inicio, fin));&#10;                visitedCells = convertCeldaPathToIntArrayPath(dfs.getRecorrido());&#10;                break;&#10;&#10;            case &quot;Backtracking&quot;:&#10;            case &quot;Recursivo (4 dir)&quot;: // Asumimos que ambos usan la misma lógica de backtracking&#10;                SolverRecursivo backtrack = new SolverRecursivo();&#10;                path = backtrack.resolverBacktracking(mazeData, startPoint.y, startPoint.x, endPoint.y, endPoint.x);&#10;                visitedCells = backtrack.getCeldasVisitadas();&#10;                break;&#10;&#10;            // Puedes añadir casos para los otros algoritmos recursivos si lo deseas&#10;&#10;            default:&#10;                path = new ArrayList&lt;&gt;();&#10;                visitedCells = new ArrayList&lt;&gt;();&#10;                view.showError(&quot;Algoritmo no reconocido o implementado.&quot;);&#10;                break;&#10;        }&#10;&#10;        long endTime = System.nanoTime();&#10;        double durationMs = (endTime - startTime) / 1_000_000.0;&#10;&#10;        // Guardar los resultados para los otros botones&#10;        this.lastFinalPath = path;&#10;        this.lastVisitedCells = visitedCells;&#10;&#10;        boolean success = !path.isEmpty();&#10;        String resultText;&#10;        if (success) {&#10;            resultText = String.format(&quot;Algoritmo: %s\nRuta encontrada.\nPasos: %d\nCeldas exploradas: %d\nTiempo: %.4f ms&quot;,&#10;                    algorithm, path.size(), visitedCells.size(), durationMs);&#10;            // Por defecto, al resolver, mostramos el camino completo&#10;            view.getMazePanel().drawFullPath(visitedCells, path);&#10;            // Preparamos el panel para la animación paso a paso&#10;            view.getMazePanel().prepareForStepByStep(path);&#10;        } else {&#10;            resultText = String.format(&quot;Algoritmo: %s\nNo se encontró ruta.\nCeldas exploradas: %d\nTiempo: %.4f ms&quot;,&#10;                    algorithm, visitedCells.size(), durationMs);&#10;            // Si no hay ruta, mostramos todas las celdas visitadas en el intento&#10;            view.getMazePanel().drawFullPath(visitedCells, null);&#10;        }&#10;        view.setResults(resultText);&#10;        csvLogger.logResult(algorithm, success, path.size(), durationMs);&#10;    }&#10;&#10;    // --- NUEVO: Método para el botón &quot;Mostrar Camino Completo&quot; ---&#10;    private void showFullPath() {&#10;        if (lastVisitedCells == null) {&#10;            view.showError(&quot;Primero debes resolver el laberinto con el botón '¡Resolver!'.&quot;);&#10;            return;&#10;        }&#10;        view.getMazePanel().drawFullPath(lastVisitedCells, lastFinalPath);&#10;    }&#10;&#10;    // --- NUEVO: Método para el botón &quot;Resolver Paso a Paso&quot; ---&#10;    private void showNextStep() {&#10;        if (lastFinalPath == null) {&#10;            view.showError(&quot;Primero debes resolver el laberinto con el botón '¡Resolver!'.&quot;);&#10;            return;&#10;        }&#10;        if (lastFinalPath.isEmpty()) {&#10;            view.showError(&quot;No se encontró una ruta para mostrar paso a paso.&quot;);&#10;            return;&#10;        }&#10;        view.getMazePanel().nextStep();&#10;    }&#10;&#10;    private void clearAll() {&#10;        view.getMazePanel().clearMaze();&#10;        view.getControlPanel().setResultsText(&quot;&quot;);&#10;        lastFinalPath = null;&#10;        lastVisitedCells = null;&#10;    }&#10;&#10;    // --- Métodos de utilidad ---&#10;    private Laberinto createLaberintoFromData(int[][] mazeData) {&#10;        Laberinto laberinto = new Laberinto(mazeData.length, mazeData[0].length);&#10;        for (int i = 0; i &lt; mazeData.length; i++) {&#10;            for (int j = 0; j &lt; mazeData[0].length; j++) {&#10;                if (mazeData[i][j] == 0) {&#10;                    laberinto.setMuro(i, j);&#10;                }&#10;            }&#10;        }&#10;        return laberinto;&#10;    }&#10;&#10;    private List&lt;int[]&gt; convertCeldaPathToIntArrayPath(List&lt;Celda&gt; celdaPath) {&#10;        if (celdaPath == null) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;        return celdaPath.stream()&#10;                .map(c -&gt; new int[]{c.getFila(), c.getColumna()})&#10;                .collect(Collectors.toList());&#10;    }&#10;}" />
              <option name="updatedContent" value="// /src/main/java/controlador/Controller.java&#10;package controlador;&#10;&#10;import modelo.*;&#10;import vista.MazeView;&#10;import util.CSVLogger;&#10;&#10;import java.awt.Point;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Controlador principal de la aplicación de laberintos.&#10; * Implementa el patrón MVC (Modelo-Vista-Controlador) gestionando la interacción&#10; * entre la interfaz gráfica y los algoritmos de resolución.&#10; *&#10; * Responsabilidades:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Gestiona eventos de la interfaz de usuario&lt;/li&gt;&#10; *   &lt;li&gt;Coordina la ejecución de algoritmos de búsqueda&lt;/li&gt;&#10; *   &lt;li&gt;Registra resultados en CSV para análisis&lt;/li&gt;&#10; *   &lt;li&gt;Maneja la validación de datos y errores&lt;/li&gt;&#10; *   &lt;li&gt;Actualiza la vista con los resultados&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @author Israel Orellana&#10; * @version 2.0&#10; */&#10;public class Controller {&#10;    private final MazeView view;&#10;    private final CSVLogger csvLogger;&#10;&#10;    // --- NUEVO: Atributos para guardar el último resultado ---&#10;    private List&lt;int[]&gt; lastFinalPath;&#10;    private List&lt;int[]&gt; lastVisitedCells;&#10;&#10;    public Controller(MazeView view) {&#10;        this.view = view;&#10;        this.csvLogger = new CSVLogger(&quot;resultados_laberinto.csv&quot;);&#10;        this.lastFinalPath = null;&#10;        this.lastVisitedCells = null;&#10;        initController();&#10;    }&#10;&#10;    private void initController() {&#10;        view.getControlPanel().addGenerateListener(e -&gt; generateNewMaze());&#10;        view.getControlPanel().addSolveListener(e -&gt; solveMaze());&#10;        view.getControlPanel().addClearAllListener(e -&gt; clearAll());&#10;&#10;        // --- NUEVO: Listeners para los nuevos botones ---&#10;        view.getControlPanel().addShowFullPathListener(e -&gt; showFullPath());&#10;        view.getControlPanel().addStepByStepListener(e -&gt; showNextStep());&#10;&#10;        // Listeners existentes para reportes&#10;        view.addListResultsListener(e -&gt; view.showResultsTable());&#10;        view.addShowTimesChartListener(e -&gt; view.showTimesChart());&#10;    }&#10;&#10;    private void generateNewMaze() {&#10;        int rows = view.getControlPanel().getRows();&#10;        int cols = view.getControlPanel().getCols();&#10;        view.getMazePanel().setMazeData(new int[rows][cols]);&#10;        view.getMazePanel().clearMaze();&#10;        view.pack();&#10;        // Limpiar resultados al generar nuevo laberinto&#10;        lastFinalPath = null;&#10;        lastVisitedCells = null;&#10;    }&#10;&#10;    private void solveMaze() {&#10;        view.getMazePanel().clearVisuals(); // Limpia dibujos anteriores&#10;&#10;        int[][] mazeData = view.getMazePanel().getMazeData();&#10;        Point startPoint = view.getMazePanel().getStartPoint();&#10;        Point endPoint = view.getMazePanel().getEndPoint();&#10;        String algorithm = view.getControlPanel().getSelectedAlgorithm();&#10;&#10;        if (startPoint == null || endPoint == null) {&#10;            view.showError(&quot;Por favor, defina un punto de inicio y fin.&quot;);&#10;            return;&#10;        }&#10;        // ... (otras validaciones que ya tenías)&#10;&#10;        List&lt;int[]&gt; path;&#10;        List&lt;int[]&gt; visitedCells;&#10;&#10;        long startTime = System.nanoTime();&#10;&#10;        // --- Lógica de ejecución movida aquí ---&#10;        Laberinto laberinto = createLaberintoFromData(mazeData);&#10;        Celda inicio = laberinto.getCelda(startPoint.y, startPoint.x);&#10;        Celda fin = laberinto.getCelda(endPoint.y, endPoint.x);&#10;&#10;        switch (algorithm) {&#10;            case &quot;BFS&quot;:&#10;                SolverBFS bfs = new SolverBFS();&#10;                path = convertCeldaPathToIntArrayPath(bfs.buscarRuta(laberinto, inicio, fin));&#10;                visitedCells = convertCeldaPathToIntArrayPath(bfs.getRecorrido());&#10;                break;&#10;&#10;            case &quot;DFS&quot;:&#10;                SolverDFS dfs = new SolverDFS();&#10;                path = convertCeldaPathToIntArrayPath(dfs.buscarRuta(laberinto, inicio, fin));&#10;                visitedCells = convertCeldaPathToIntArrayPath(dfs.getRecorrido());&#10;                break;&#10;&#10;            case &quot;Backtracking&quot;:&#10;            case &quot;Recursivo (4 dir)&quot;: // Asumimos que ambos usan la misma lógica de backtracking&#10;                SolverRecursivo backtrack = new SolverRecursivo();&#10;                path = backtrack.resolverBacktracking(mazeData, startPoint.y, startPoint.x, endPoint.y, endPoint.x);&#10;                visitedCells = backtrack.getCeldasVisitadas();&#10;                break;&#10;&#10;            // Puedes añadir casos para los otros algoritmos recursivos si lo deseas&#10;&#10;            default:&#10;                path = new ArrayList&lt;&gt;();&#10;                visitedCells = new ArrayList&lt;&gt;();&#10;                view.showError(&quot;Algoritmo no reconocido o implementado.&quot;);&#10;                break;&#10;        }&#10;&#10;        long endTime = System.nanoTime();&#10;        double durationMs = (endTime - startTime) / 1_000_000.0;&#10;&#10;        // Guardar los resultados para los otros botones&#10;        this.lastFinalPath = path;&#10;        this.lastVisitedCells = visitedCells;&#10;&#10;        boolean success = !path.isEmpty();&#10;        String resultText;&#10;        if (success) {&#10;            resultText = String.format(&quot;Algoritmo: %s\nRuta encontrada.\nPasos: %d\nCeldas exploradas: %d\nTiempo: %.4f ms&quot;,&#10;                    algorithm, path.size(), visitedCells.size(), durationMs);&#10;            // Por defecto, al resolver, mostramos el camino completo&#10;            view.getMazePanel().drawFullPath(visitedCells, path);&#10;            // Preparamos el panel para la animación paso a paso&#10;            view.getMazePanel().prepareForStepByStep(path);&#10;        } else {&#10;            resultText = String.format(&quot;Algoritmo: %s\nNo se encontró ruta.\nCeldas exploradas: %d\nTiempo: %.4f ms&quot;,&#10;                    algorithm, visitedCells.size(), durationMs);&#10;            // Si no hay ruta, mostramos todas las celdas visitadas en el intento&#10;            view.getMazePanel().drawFullPath(visitedCells, null);&#10;        }&#10;        view.setResults(resultText);&#10;        csvLogger.logResult(algorithm, success, path.size(), durationMs);&#10;    }&#10;&#10;    // --- NUEVO: Método para el botón &quot;Mostrar Camino Completo&quot; ---&#10;    private void showFullPath() {&#10;        if (lastVisitedCells == null) {&#10;            view.showError(&quot;Primero debes resolver el laberinto con el botón '¡Resolver!'.&quot;);&#10;            return;&#10;        }&#10;        view.getMazePanel().drawFullPath(lastVisitedCells, lastFinalPath);&#10;    }&#10;&#10;    // --- NUEVO: Método para el botón &quot;Resolver Paso a Paso&quot; ---&#10;    private void showNextStep() {&#10;        if (lastFinalPath == null) {&#10;            view.showError(&quot;Primero debes resolver el laberinto con el botón '¡Resolver!'.&quot;);&#10;            return;&#10;        }&#10;        if (lastFinalPath.isEmpty()) {&#10;            view.showError(&quot;No se encontró una ruta para mostrar paso a paso.&quot;);&#10;            return;&#10;        }&#10;        view.getMazePanel().nextStep();&#10;    }&#10;&#10;    private void clearAll() {&#10;        view.getMazePanel().clearMaze();&#10;        view.getControlPanel().setResultsText(&quot;&quot;);&#10;        lastFinalPath = null;&#10;        lastVisitedCells = null;&#10;    }&#10;&#10;    // --- Métodos de utilidad ---&#10;    private Laberinto createLaberintoFromData(int[][] mazeData) {&#10;        Laberinto laberinto = new Laberinto(mazeData.length, mazeData[0].length);&#10;        for (int i = 0; i &lt; mazeData.length; i++) {&#10;            for (int j = 0; j &lt; mazeData[0].length; j++) {&#10;                if (mazeData[i][j] == 0) {&#10;                    laberinto.setMuro(i, j);&#10;                }&#10;            }&#10;        }&#10;        return laberinto;&#10;    }&#10;&#10;    private List&lt;int[]&gt; convertCeldaPathToIntArrayPath(List&lt;Celda&gt; celdaPath) {&#10;        if (celdaPath == null) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;        return celdaPath.stream()&#10;                .map(c -&gt; new int[]{c.getFila(), c.getColumna()})&#10;                .collect(Collectors.toList());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/modelo/Celda.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/modelo/Celda.java" />
              <option name="originalContent" value="package modelo;&#10;&#10;/**&#10; * Representa una celda individual dentro del laberinto.&#10; * Cada celda se define por sus coordenadas (fila y columna) y un estado que&#10; * indica si es transitable (parte del camino) o un muro.&#10; *&#10; * @author Juan Pablo Ortiz&#10; * @version 1.0&#10; */&#10;public class Celda {&#10;    private int fila;&#10;    private int columna;&#10;    private boolean transitable;&#10;&#10;    /**&#10;     * Constructor para crear una nueva celda.&#10;     *&#10;     *&#10;     * @param fila La coordenada de la fila de la celda.&#10;     * @param columna La coordenada de la columna de la celda.&#10;     * @param transitable Un valor booleano que indica si la celda es transitable ({@code true}) o un muro ({@code false}).&#10;     */&#10;    public Celda(int fila, int columna, boolean transitable) {&#10;        this.fila = fila;&#10;        this.columna = columna;&#10;        this.transitable = transitable;&#10;    }&#10;&#10;    /**&#10;     * Obtiene la coordenada de la fila de la celda.&#10;     *&#10;     * @return El número de la fila.&#10;     */&#10;    public int getFila() {&#10;        return fila;&#10;    }&#10;&#10;    /**&#10;     * Obtiene la coordenada de la columna de la celda.&#10;     *&#10;     * @return El número de la columna.&#10;     */&#10;    public int getColumna() {&#10;        return columna;&#10;    }&#10;&#10;    /**&#10;     * Verifica si la celda es transitable.&#10;     *&#10;     * @return {@code true} si la celda es transitable, {@code false} si es un muro.&#10;     */&#10;    public boolean esTransitable() {&#10;        return transitable;&#10;    }&#10;&#10;    /**&#10;     * Establece el estado de transitabilidad de la celda.&#10;     *&#10;     * @param transitable Un valor booleano que indica si la celda debe ser transitable.&#10;     */&#10;    public void setTransitable(boolean transitable) {&#10;        this.transitable = transitable;&#10;    }&#10;&#10;    /**&#10;     * Devuelve una representación en cadena de la celda, mostrando sus coordenadas.&#10;     *&#10;     * @return Una cadena con el formato &quot;[row=fila, col=columna]&quot;.&#10;     */&#10;    @Override&#10;    public String toString() {&#10;        return &quot;[row=&quot; + fila + &quot;, col=&quot; + columna + &quot;]&quot;;&#10;    }&#10;&#10;    /**&#10;     * Genera un valor de código hash para la celda. Este metodo es útil para&#10;     * almacenar objetos Celda en estructuras de datos como {@code HashMap} o {@code HashSet}.&#10;     *&#10;     * @return El valor del código hash.&#10;     */&#10;    @Override&#10;    public int hashCode() {&#10;        final int prime = 31;&#10;        int result = 1;&#10;        result = prime * result + fila;&#10;        result = prime * result + columna;&#10;        return result;&#10;    }&#10;&#10;    /**&#10;     * Compara esta celda con otro objeto para determinar si son iguales.&#10;     * Dos celdas se consideran iguales si tienen las mismas coordenadas de fila y columna.&#10;     *&#10;     * @param obj El objeto con el que se va a comparar.&#10;     * @return {@code true} si el objeto es una Celda con las mismas coordenadas, {@code false} en caso contrario.&#10;     */&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj)&#10;            return true;&#10;        if (obj == null)&#10;            return false;&#10;        if (getClass() != obj.getClass())&#10;            return false;&#10;        Celda other = (Celda) obj;&#10;        if (fila != other.fila)&#10;            return false;&#10;        if (columna != other.columna)&#10;            return false;&#10;        return true;&#10;    }&#10;}" />
              <option name="updatedContent" value="package modelo;&#10;&#10;/**&#10; * Representa una celda individual en el laberinto.&#10; * Cada celda tiene una posición (fila, columna) y puede ser transitable o un muro.&#10; * Se utiliza como componente básico para construir el laberinto y para los algoritmos&#10; * de búsqueda de caminos.&#10; *&#10; * Características:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Mantiene su posición en el laberinto (fila, columna)&lt;/li&gt;&#10; *   &lt;li&gt;Puede ser marcada como muro o celda transitable&lt;/li&gt;&#10; *   &lt;li&gt;Implementa equals y hashCode para su uso en colecciones&lt;/li&gt;&#10; *   &lt;li&gt;Proporciona métodos de acceso a sus propiedades&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @author Israel Orellana&#10; * @version 1.0&#10; */&#10;public class Celda {&#10;    private int fila;&#10;    private int columna;&#10;    private boolean transitable;&#10;&#10;    /**&#10;     * Constructor para crear una nueva celda.&#10;     *&#10;     *&#10;     * @param fila La coordenada de la fila de la celda.&#10;     * @param columna La coordenada de la columna de la celda.&#10;     * @param transitable Un valor booleano que indica si la celda es transitable ({@code true}) o un muro ({@code false}).&#10;     */&#10;    public Celda(int fila, int columna, boolean transitable) {&#10;        this.fila = fila;&#10;        this.columna = columna;&#10;        this.transitable = transitable;&#10;    }&#10;&#10;    /**&#10;     * Obtiene la coordenada de la fila de la celda.&#10;     *&#10;     * @return El número de la fila.&#10;     */&#10;    public int getFila() {&#10;        return fila;&#10;    }&#10;&#10;    /**&#10;     * Obtiene la coordenada de la columna de la celda.&#10;     *&#10;     * @return El número de la columna.&#10;     */&#10;    public int getColumna() {&#10;        return columna;&#10;    }&#10;&#10;    /**&#10;     * Verifica si la celda es transitable.&#10;     *&#10;     * @return {@code true} si la celda es transitable, {@code false} si es un muro.&#10;     */&#10;    public boolean esTransitable() {&#10;        return transitable;&#10;    }&#10;&#10;    /**&#10;     * Establece el estado de transitabilidad de la celda.&#10;     *&#10;     * @param transitable Un valor booleano que indica si la celda debe ser transitable.&#10;     */&#10;    public void setTransitable(boolean transitable) {&#10;        this.transitable = transitable;&#10;    }&#10;&#10;    /**&#10;     * Devuelve una representación en cadena de la celda, mostrando sus coordenadas.&#10;     *&#10;     * @return Una cadena con el formato &quot;[row=fila, col=columna]&quot;.&#10;     */&#10;    @Override&#10;    public String toString() {&#10;        return &quot;[row=&quot; + fila + &quot;, col=&quot; + columna + &quot;]&quot;;&#10;    }&#10;&#10;    /**&#10;     * Genera un valor de código hash para la celda. Este metodo es útil para&#10;     * almacenar objetos Celda en estructuras de datos como {@code HashMap} o {@code HashSet}.&#10;     *&#10;     * @return El valor del código hash.&#10;     */&#10;    @Override&#10;    public int hashCode() {&#10;        final int prime = 31;&#10;        int result = 1;&#10;        result = prime * result + fila;&#10;        result = prime * result + columna;&#10;        return result;&#10;    }&#10;&#10;    /**&#10;     * Compara esta celda con otro objeto para determinar si son iguales.&#10;     * Dos celdas se consideran iguales si tienen las mismas coordenadas de fila y columna.&#10;     *&#10;     * @param obj El objeto con el que se va a comparar.&#10;     * @return {@code true} si el objeto es una Celda con las mismas coordenadas, {@code false} en caso contrario.&#10;     */&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj)&#10;            return true;&#10;        if (obj == null)&#10;            return false;&#10;        if (getClass() != obj.getClass())&#10;            return false;&#10;        Celda other = (Celda) obj;&#10;        if (fila != other.fila)&#10;            return false;&#10;        if (columna != other.columna)&#10;            return false;&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/modelo/Laberinto.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/modelo/Laberinto.java" />
              <option name="originalContent" value="package modelo;&#10;&#10;/**&#10; * Representa la estructura del laberinto como una matriz de objetos {@link Celda}.&#10; * Esta clase se encarga de la gestión de las celdas, el establecimiento de muros&#10; * y la provisión de información sobre las dimensiones del laberinto.&#10; *&#10; * @author Juan Pablo Ortiz&#10; * @version 1.0&#10; */&#10;public class Laberinto {&#10;    private Celda[][] matriz;&#10;    private int filas;&#10;    private int columnas;&#10;&#10;    /**&#10;     * Constructor para crear un nuevo laberinto de un tamaño específico.&#10;     * Por defecto, todas las celdas son transitables.&#10;     *&#10;     * @param filas El número de filas del laberinto.&#10;     * @param columnas El número de columnas del laberinto.&#10;     */&#10;    public Laberinto(int filas, int columnas) {&#10;        this.filas = filas;&#10;        this.columnas = columnas;&#10;        matriz = new Celda[filas][columnas];&#10;        for (int i = 0; i &lt; filas; i++) {&#10;            for (int j = 0; j &lt; columnas; j++) {&#10;                matriz[i][j] = new Celda(i, j, true); // Por defecto, todo transitable&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Establece una celda específica como un muro (no transitable).&#10;     *&#10;     * @param fila La coordenada de la fila de la celda.&#10;     * @param columna La coordenada de la columna de la celda.&#10;     */&#10;    public void setMuro(int fila, int columna) {&#10;        matriz[fila][columna].setTransitable(false);&#10;    }&#10;&#10;    /**&#10;     * Establece una celda específica como transitable.&#10;     *&#10;     * @param fila La coordenada de la fila de la celda.&#10;     * @param columna La coordenada de la columna de la celda.&#10;     */&#10;    public void setTransitable(int fila, int columna) {&#10;        matriz[fila][columna].setTransitable(true);&#10;    }&#10;&#10;    /**&#10;     * Obtiene el objeto Celda en las coordenadas especificadas.&#10;     *&#10;     * @param fila La coordenada de la fila.&#10;     * @param columna La coordenada de la columna.&#10;     * @return El objeto Celda en la posición (fila, columna).&#10;     */&#10;    public Celda getCelda(int fila, int columna) {&#10;        return matriz[fila][columna];&#10;    }&#10;&#10;    /**&#10;     * Obtiene el número total de filas del laberinto.&#10;     *&#10;     * @return El número de filas.&#10;     */&#10;    public int getFilas() {&#10;        return filas;&#10;    }&#10;&#10;    /**&#10;     * Obtiene el número total de columnas del laberinto.&#10;     *&#10;     * @return El número de columnas.&#10;     */&#10;    public int getColumnas() {&#10;        return columnas;&#10;    }&#10;&#10;    /**&#10;     * Devuelve el laberinto como una matriz de enteros, donde 1 representa una&#10;     * celda transitable y 0 representa un muro.&#10;     *&#10;     * @return Una matriz bidimensional de enteros que representa el laberinto.&#10;     */&#10;    public int[][] aMatrizEnteros() {&#10;        int[][] mat = new int[filas][columnas];&#10;        for (int i = 0; i &lt; filas; i++) {&#10;            for (int j = 0; j &lt; columnas; j++) {&#10;                mat[i][j] = matriz[i][j].esTransitable() ? 1 : 0;&#10;            }&#10;        }&#10;        return mat;&#10;    }&#10;}" />
              <option name="updatedContent" value="package modelo;&#10;&#10;/**&#10; * Representa la estructura completa del laberinto.&#10; * Mantiene una matriz de celdas y proporciona métodos para manipular&#10; * y consultar el estado del laberinto.&#10; *&#10; * Características:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Gestiona una matriz bidimensional de celdas&lt;/li&gt;&#10; *   &lt;li&gt;Permite colocar y quitar muros&lt;/li&gt;&#10; *   &lt;li&gt;Provee acceso a celdas individuales&lt;/li&gt;&#10; *   &lt;li&gt;Permite convertir el laberinto a formato de matriz de enteros&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @author Israel Orellana&#10; * @version 1.0&#10; */&#10;public class Laberinto {&#10;    private Celda[][] matriz;&#10;    private int filas;&#10;    private int columnas;&#10;&#10;    /**&#10;     * Constructor para crear un nuevo laberinto de un tamaño específico.&#10;     * Por defecto, todas las celdas son transitables.&#10;     *&#10;     * @param filas El número de filas del laberinto.&#10;     * @param columnas El número de columnas del laberinto.&#10;     */&#10;    public Laberinto(int filas, int columnas) {&#10;        this.filas = filas;&#10;        this.columnas = columnas;&#10;        matriz = new Celda[filas][columnas];&#10;        for (int i = 0; i &lt; filas; i++) {&#10;            for (int j = 0; j &lt; columnas; j++) {&#10;                matriz[i][j] = new Celda(i, j, true); // Por defecto, todo transitable&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Establece una celda específica como un muro (no transitable).&#10;     *&#10;     * @param fila La coordenada de la fila de la celda.&#10;     * @param columna La coordenada de la columna de la celda.&#10;     */&#10;    public void setMuro(int fila, int columna) {&#10;        matriz[fila][columna].setTransitable(false);&#10;    }&#10;&#10;    /**&#10;     * Establece una celda específica como transitable.&#10;     *&#10;     * @param fila La coordenada de la fila de la celda.&#10;     * @param columna La coordenada de la columna de la celda.&#10;     */&#10;    public void setTransitable(int fila, int columna) {&#10;        matriz[fila][columna].setTransitable(true);&#10;    }&#10;&#10;    /**&#10;     * Obtiene el objeto Celda en las coordenadas especificadas.&#10;     *&#10;     * @param fila La coordenada de la fila.&#10;     * @param columna La coordenada de la columna.&#10;     * @return El objeto Celda en la posición (fila, columna).&#10;     */&#10;    public Celda getCelda(int fila, int columna) {&#10;        return matriz[fila][columna];&#10;    }&#10;&#10;    /**&#10;     * Obtiene el número total de filas del laberinto.&#10;     *&#10;     * @return El número de filas.&#10;     */&#10;    public int getFilas() {&#10;        return filas;&#10;    }&#10;&#10;    /**&#10;     * Obtiene el número total de columnas del laberinto.&#10;     *&#10;     * @return El número de columnas.&#10;     */&#10;    public int getColumnas() {&#10;        return columnas;&#10;    }&#10;&#10;    /**&#10;     * Devuelve el laberinto como una matriz de enteros, donde 1 representa una&#10;     * celda transitable y 0 representa un muro.&#10;     *&#10;     * @return Una matriz bidimensional de enteros que representa el laberinto.&#10;     */&#10;    public int[][] aMatrizEnteros() {&#10;        int[][] mat = new int[filas][columnas];&#10;        for (int i = 0; i &lt; filas; i++) {&#10;            for (int j = 0; j &lt; columnas; j++) {&#10;                mat[i][j] = matriz[i][j].esTransitable() ? 1 : 0;&#10;            }&#10;        }&#10;        return mat;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/modelo/SolverBFS.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/modelo/SolverBFS.java" />
              <option name="originalContent" value="package modelo;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;&#10;/**&#10; * Clase que implementa el algoritmo de Búsqueda en Amplitud (BFS)&#10; * para encontrar la ruta más corta en un laberinto.&#10; *&#10; * @author Juan Pablo Ortiz&#10; * @version 1.1&#10; */&#10;public class SolverBFS {&#10;&#10;    // Movimientos para 4 direcciones: arriba, abajo, izquierda, derecha&#10;    private static final int[] dx = {-1, 1, 0, 0};&#10;    private static final int[] dy = {0, 0, -1, 1};&#10;&#10;    /** Lista que almacena el orden en que las celdas fueron visitadas para el recorrido. */&#10;    private List&lt;Celda&gt; recorrido;&#10;&#10;    /**&#10;     * Devuelve la lista de celdas visitadas en el orden de exploración.&#10;     * Esta lista puede ser utilizada por el controlador para animar el proceso de búsqueda.&#10;     *&#10;     * @return Una lista de celdas que representa el recorrido completo del algoritmo.&#10;     */&#10;    public List&lt;Celda&gt; getRecorrido() {&#10;        return recorrido;&#10;    }&#10;&#10;    /**&#10;     * Busca la ruta más corta desde un punto de inicio hasta un punto de destino&#10;     * en un laberinto usando el algoritmo BFS.&#10;     * @param laberinto El objeto Laberinto que contiene la matriz de celdas.&#10;     * @param inicio La celda de inicio.&#10;     * @param fin La celda de destino.&#10;     * @return Una lista de celdas que representa la ruta más corta, o una lista vacía si no hay ruta.&#10;     */&#10;    public List&lt;Celda&gt; buscarRuta(Laberinto laberinto, Celda inicio, Celda fin) {&#10;        if (laberinto == null || inicio == null || fin == null) {&#10;            return Collections.emptyList();&#10;        }&#10;&#10;        Queue&lt;Celda&gt; cola = new LinkedList&lt;&gt;();&#10;        boolean[][] visitado = new boolean[laberinto.getFilas()][laberinto.getColumnas()];&#10;        Celda[][] predecesor = new Celda[laberinto.getFilas()][laberinto.getColumnas()];&#10;        this.recorrido = new ArrayList&lt;&gt;(); // Inicializar la lista de recorrido al inicio de la búsqueda&#10;&#10;        cola.add(inicio);&#10;        visitado[inicio.getFila()][inicio.getColumna()] = true;&#10;        this.recorrido.add(inicio); // Añadir el inicio al recorrido&#10;&#10;        while (!cola.isEmpty()) {&#10;            Celda actual = cola.poll();&#10;&#10;            // Usamos las coordenadas para la comparación de celdas&#10;            if (actual.getFila() == fin.getFila() &amp;&amp; actual.getColumna() == fin.getColumna()) {&#10;                // Al encontrar la solución, añadimos el destino al recorrido&#10;                this.recorrido.add(fin);&#10;                return reconstruirRuta(predecesor, inicio, fin);&#10;            }&#10;&#10;            for (int i = 0; i &lt; 4; i++) {&#10;                int nuevaFila = actual.getFila() + dx[i];&#10;                int nuevaColumna = actual.getColumna() + dy[i];&#10;&#10;                if (esValido(laberinto, nuevaFila, nuevaColumna, visitado)) {&#10;                    Celda vecino = laberinto.getCelda(nuevaFila, nuevaColumna);&#10;                    visitado[nuevaFila][nuevaColumna] = true;&#10;                    predecesor[nuevaFila][nuevaColumna] = actual;&#10;                    cola.add(vecino);&#10;                    this.recorrido.add(vecino); // Añadir la celda visitada al recorrido&#10;                }&#10;            }&#10;        }&#10;        return Collections.emptyList(); // No se encontró ruta&#10;    }&#10;&#10;    /**&#10;     * Reconstruye la ruta desde el destino hasta el inicio usando el arreglo de predecesores.&#10;     */&#10;    private List&lt;Celda&gt; reconstruirRuta(Celda[][] predecesor, Celda inicio, Celda fin) {&#10;        List&lt;Celda&gt; ruta = new ArrayList&lt;&gt;();&#10;        for (Celda at = fin; at != null; at = predecesor[at.getFila()][at.getColumna()]) {&#10;            ruta.add(at);&#10;        }&#10;        Collections.reverse(ruta);&#10;        return ruta;&#10;    }&#10;&#10;    /**&#10;     * Verifica si una celda es válida para el movimiento.&#10;     */&#10;    private boolean esValido(Laberinto laberinto, int fila, int columna, boolean[][] visitado) {&#10;        int filas = laberinto.getFilas();&#10;        int columnas = laberinto.getColumnas();&#10;        if (fila &lt; 0 || fila &gt;= filas || columna &lt; 0 || columna &gt;= columnas) {&#10;            return false;&#10;        }&#10;        if (visitado[fila][columna] || !laberinto.getCelda(fila, columna).esTransitable()) {&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;}" />
              <option name="updatedContent" value="package modelo;&#13;&#10;&#13;&#10;import java.util.LinkedList;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Queue;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.Collections;&#13;&#10;&#13;&#10;/**&#13;&#10; * Implementa el algoritmo de búsqueda en anchura (Breadth-First Search)&#13;&#10; * para encontrar el camino más corto en el laberinto.&#13;&#10; *&#13;&#10; * Características:&#13;&#10; * &lt;ul&gt;&#13;&#10; *   &lt;li&gt;Garantiza encontrar el camino más corto si existe&lt;/li&gt;&#13;&#10; *   &lt;li&gt;Utiliza una cola para explorar el laberinto nivel por nivel&lt;/li&gt;&#13;&#10; *   &lt;li&gt;Mantiene un registro de celdas visitadas&lt;/li&gt;&#13;&#10; *   &lt;li&gt;Construye el camino desde el destino hacia el inicio&lt;/li&gt;&#13;&#10; * &lt;/ul&gt;&#13;&#10; *&#13;&#10; * @author Israel Orellana&#13;&#10; * @version 1.0&#13;&#10; */&#13;&#10;public class SolverBFS {&#13;&#10;&#13;&#10;    // Movimientos para 4 direcciones: arriba, abajo, izquierda, derecha&#13;&#10;    private static final int[] dx = {-1, 1, 0, 0};&#13;&#10;    private static final int[] dy = {0, 0, -1, 1};&#13;&#10;&#13;&#10;    /** Lista que almacena el orden en que las celdas fueron visitadas para el recorrido. */&#13;&#10;    private List&lt;Celda&gt; recorrido;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Devuelve la lista de celdas visitadas en el orden de exploración.&#13;&#10;     * Esta lista puede ser utilizada por el controlador para animar el proceso de búsqueda.&#13;&#10;     *&#13;&#10;     * @return Una lista de celdas que representa el recorrido completo del algoritmo.&#13;&#10;     */&#13;&#10;    public List&lt;Celda&gt; getRecorrido() {&#13;&#10;        return recorrido;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Busca la ruta más corta desde un punto de inicio hasta un punto de destino&#13;&#10;     * en un laberinto usando el algoritmo BFS.&#13;&#10;     * @param laberinto El objeto Laberinto que contiene la matriz de celdas.&#13;&#10;     * @param inicio La celda de inicio.&#13;&#10;     * @param fin La celda de destino.&#13;&#10;     * @return Una lista de celdas que representa la ruta más corta, o una lista vacía si no hay ruta.&#13;&#10;     */&#13;&#10;    public List&lt;Celda&gt; buscarRuta(Laberinto laberinto, Celda inicio, Celda fin) {&#13;&#10;        if (laberinto == null || inicio == null || fin == null) {&#13;&#10;            return Collections.emptyList();&#13;&#10;        }&#13;&#10;&#13;&#10;        Queue&lt;Celda&gt; cola = new LinkedList&lt;&gt;();&#13;&#10;        boolean[][] visitado = new boolean[laberinto.getFilas()][laberinto.getColumnas()];&#13;&#10;        Celda[][] predecesor = new Celda[laberinto.getFilas()][laberinto.getColumnas()];&#13;&#10;        this.recorrido = new ArrayList&lt;&gt;(); // Inicializar la lista de recorrido al inicio de la búsqueda&#13;&#10;&#13;&#10;        cola.add(inicio);&#13;&#10;        visitado[inicio.getFila()][inicio.getColumna()] = true;&#13;&#10;        this.recorrido.add(inicio); // Añadir el inicio al recorrido&#13;&#10;&#13;&#10;        while (!cola.isEmpty()) {&#13;&#10;            Celda actual = cola.poll();&#13;&#10;&#13;&#10;            // Usamos las coordenadas para la comparación de celdas&#13;&#10;            if (actual.getFila() == fin.getFila() &amp;&amp; actual.getColumna() == fin.getColumna()) {&#13;&#10;                // Al encontrar la solución, añadimos el destino al recorrido&#13;&#10;                this.recorrido.add(fin);&#13;&#10;                return reconstruirRuta(predecesor, inicio, fin);&#13;&#10;            }&#13;&#10;&#13;&#10;            for (int i = 0; i &lt; 4; i++) {&#13;&#10;                int nuevaFila = actual.getFila() + dx[i];&#13;&#10;                int nuevaColumna = actual.getColumna() + dy[i];&#13;&#10;&#13;&#10;                if (esValido(laberinto, nuevaFila, nuevaColumna, visitado)) {&#13;&#10;                    Celda vecino = laberinto.getCelda(nuevaFila, nuevaColumna);&#13;&#10;                    visitado[nuevaFila][nuevaColumna] = true;&#13;&#10;                    predecesor[nuevaFila][nuevaColumna] = actual;&#13;&#10;                    cola.add(vecino);&#13;&#10;                    this.recorrido.add(vecino); // Añadir la celda visitada al recorrido&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;        return Collections.emptyList(); // No se encontró ruta&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Reconstruye la ruta desde el destino hasta el inicio usando el arreglo de predecesores.&#13;&#10;     */&#13;&#10;    private List&lt;Celda&gt; reconstruirRuta(Celda[][] predecesor, Celda inicio, Celda fin) {&#13;&#10;        List&lt;Celda&gt; ruta = new ArrayList&lt;&gt;();&#13;&#10;        for (Celda at = fin; at != null; at = predecesor[at.getFila()][at.getColumna()]) {&#13;&#10;            ruta.add(at);&#13;&#10;        }&#13;&#10;        Collections.reverse(ruta);&#13;&#10;        return ruta;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Verifica si una celda es válida para el movimiento.&#13;&#10;     */&#13;&#10;    private boolean esValido(Laberinto laberinto, int fila, int columna, boolean[][] visitado) {&#13;&#10;        int filas = laberinto.getFilas();&#13;&#10;        int columnas = laberinto.getColumnas();&#13;&#10;        if (fila &lt; 0 || fila &gt;= filas || columna &lt; 0 || columna &gt;= columnas) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        if (visitado[fila][columna] || !laberinto.getCelda(fila, columna).esTransitable()) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        return true;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/modelo/SolverDFS.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/modelo/SolverDFS.java" />
              <option name="originalContent" value="package modelo;&#10;&#10;import java.util.Stack;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;&#10;/**&#10; * Clase que implementa el algoritmo de Búsqueda en Profundidad (DFS)&#10; * para encontrar una ruta en un laberinto.&#10; *&#10; * @author Juan Pablo Ortiz&#10; * @version 1.1&#10; */&#10;public class SolverDFS {&#10;&#10;    // Movimientos para 4 direcciones: arriba, abajo, izquierda, derecha&#10;    private static final int[] dx = {-1, 1, 0, 0};&#10;    private static final int[] dy = {0, 0, -1, 1};&#10;&#10;    /** Lista que almacena el orden en que las celdas fueron visitadas para el recorrido. */&#10;    private List&lt;Celda&gt; recorrido;&#10;&#10;    /**&#10;     * Devuelve la lista de celdas visitadas en el orden de exploración.&#10;     * Esta lista puede ser utilizada por el controlador para animar el proceso de búsqueda.&#10;     *&#10;     * @return Una lista de celdas que representa el recorrido completo del algoritmo.&#10;     */&#10;    public List&lt;Celda&gt; getRecorrido() {&#10;        return recorrido;&#10;    }&#10;&#10;    /**&#10;     * Busca una ruta desde un punto de inicio hasta un punto de destino&#10;     * en un laberinto usando el algoritmo DFS (iterativo).&#10;     * @param laberinto El objeto Laberinto que contiene la matriz de celdas.&#10;     * @param inicio La celda de inicio.&#10;     * @param fin La celda de destino.&#10;     * @return Una lista de celdas que representa una ruta, o una lista vacía si no hay ruta.&#10;     */&#10;    public List&lt;Celda&gt; buscarRuta(Laberinto laberinto, Celda inicio, Celda fin) {&#10;        if (laberinto == null || inicio == null || fin == null) {&#10;            return Collections.emptyList();&#10;        }&#10;&#10;        Stack&lt;Celda&gt; pila = new Stack&lt;&gt;();&#10;        boolean[][] visitado = new boolean[laberinto.getFilas()][laberinto.getColumnas()];&#10;        Celda[][] predecesor = new Celda[laberinto.getFilas()][laberinto.getColumnas()];&#10;        this.recorrido = new ArrayList&lt;&gt;(); // Inicializar la lista de recorrido al inicio de la búsqueda&#10;&#10;        pila.push(inicio);&#10;        visitado[inicio.getFila()][inicio.getColumna()] = true;&#10;        this.recorrido.add(inicio); // Añadir el inicio al recorrido&#10;&#10;        while (!pila.isEmpty()) {&#10;            Celda actual = pila.pop();&#10;&#10;            // Usamos las coordenadas para la comparación de celdas&#10;            if (actual.getFila() == fin.getFila() &amp;&amp; actual.getColumna() == fin.getColumna()) {&#10;                // Al encontrar la solución, añadimos el destino al recorrido&#10;                this.recorrido.add(fin);&#10;                return reconstruirRuta(predecesor, inicio, fin);&#10;            }&#10;&#10;            for (int i = 0; i &lt; 4; i++) {&#10;                int nuevaFila = actual.getFila() + dx[i];&#10;                int nuevaColumna = actual.getColumna() + dy[i];&#10;&#10;                if (esValido(laberinto, nuevaFila, nuevaColumna, visitado)) {&#10;                    Celda vecino = laberinto.getCelda(nuevaFila, nuevaColumna);&#10;                    visitado[nuevaFila][nuevaColumna] = true;&#10;                    predecesor[nuevaFila][nuevaColumna] = actual;&#10;                    pila.push(vecino);&#10;                    this.recorrido.add(vecino); // Añadir la celda visitada al recorrido&#10;                }&#10;            }&#10;        }&#10;        return Collections.emptyList(); // No se encontró ruta&#10;    }&#10;&#10;    /**&#10;     * Reconstruye la ruta desde el destino hasta el inicio usando el arreglo de predecesores.&#10;     */&#10;    private List&lt;Celda&gt; reconstruirRuta(Celda[][] predecesor, Celda inicio, Celda fin) {&#10;        List&lt;Celda&gt; ruta = new ArrayList&lt;&gt;();&#10;        for (Celda at = fin; at != null; at = predecesor[at.getFila()][at.getColumna()]) {&#10;            ruta.add(at);&#10;        }&#10;        Collections.reverse(ruta);&#10;        return ruta;&#10;    }&#10;&#10;    /**&#10;     * Verifica si una celda es válida para el movimiento.&#10;     */&#10;    private boolean esValido(Laberinto laberinto, int fila, int columna, boolean[][] visitado) {&#10;        int filas = laberinto.getFilas();&#10;        int columnas = laberinto.getColumnas();&#10;        if (fila &lt; 0 || fila &gt;= filas || columna &lt; 0 || columna &gt;= columnas) {&#10;            return false;&#10;        }&#10;        if (visitado[fila][columna] || !laberinto.getCelda(fila, columna).esTransitable()) {&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;}" />
              <option name="updatedContent" value="package modelo;&#10;&#10;import java.util.Stack;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;&#10;/**&#10; * Implementa el algoritmo de búsqueda en profundidad (Depth-First Search)&#10; * para encontrar un camino en el laberinto.&#10; *&#10; * Características:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Explora el laberinto siguiendo una rama hasta el final antes de retroceder&lt;/li&gt;&#10; *   &lt;li&gt;Utiliza una pila (implícita en la recursión) para la exploración&lt;/li&gt;&#10; *   &lt;li&gt;Mantiene un registro de celdas visitadas&lt;/li&gt;&#10; *   &lt;li&gt;No garantiza encontrar el camino más corto&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @author Israel Orellana&#10; * @version 1.0&#10; */&#10;public class SolverDFS {&#10;&#10;    // Movimientos para 4 direcciones: arriba, abajo, izquierda, derecha&#10;    private static final int[] dx = {-1, 1, 0, 0};&#10;    private static final int[] dy = {0, 0, -1, 1};&#10;&#10;    /** Lista que almacena el orden en que las celdas fueron visitadas para el recorrido. */&#10;    private List&lt;Celda&gt; recorrido;&#10;&#10;    /**&#10;     * Devuelve la lista de celdas visitadas en el orden de exploración.&#10;     * Esta lista puede ser utilizada por el controlador para animar el proceso de búsqueda.&#10;     *&#10;     * @return Una lista de celdas que representa el recorrido completo del algoritmo.&#10;     */&#10;    public List&lt;Celda&gt; getRecorrido() {&#10;        return recorrido;&#10;    }&#10;&#10;    /**&#10;     * Busca una ruta desde un punto de inicio hasta un punto de destino&#10;     * en un laberinto usando el algoritmo DFS (iterativo).&#10;     * @param laberinto El objeto Laberinto que contiene la matriz de celdas.&#10;     * @param inicio La celda de inicio.&#10;     * @param fin La celda de destino.&#10;     * @return Una lista de celdas que representa una ruta, o una lista vacía si no hay ruta.&#10;     */&#10;    public List&lt;Celda&gt; buscarRuta(Laberinto laberinto, Celda inicio, Celda fin) {&#10;        if (laberinto == null || inicio == null || fin == null) {&#10;            return Collections.emptyList();&#10;        }&#10;&#10;        Stack&lt;Celda&gt; pila = new Stack&lt;&gt;();&#10;        boolean[][] visitado = new boolean[laberinto.getFilas()][laberinto.getColumnas()];&#10;        Celda[][] predecesor = new Celda[laberinto.getFilas()][laberinto.getColumnas()];&#10;        this.recorrido = new ArrayList&lt;&gt;(); // Inicializar la lista de recorrido al inicio de la búsqueda&#10;&#10;        pila.push(inicio);&#10;        visitado[inicio.getFila()][inicio.getColumna()] = true;&#10;        this.recorrido.add(inicio); // Añadir el inicio al recorrido&#10;&#10;        while (!pila.isEmpty()) {&#10;            Celda actual = pila.pop();&#10;&#10;            // Usamos las coordenadas para la comparación de celdas&#10;            if (actual.getFila() == fin.getFila() &amp;&amp; actual.getColumna() == fin.getColumna()) {&#10;                // Al encontrar la solución, añadimos el destino al recorrido&#10;                this.recorrido.add(fin);&#10;                return reconstruirRuta(predecesor, inicio, fin);&#10;            }&#10;&#10;            for (int i = 0; i &lt; 4; i++) {&#10;                int nuevaFila = actual.getFila() + dx[i];&#10;                int nuevaColumna = actual.getColumna() + dy[i];&#10;&#10;                if (esValido(laberinto, nuevaFila, nuevaColumna, visitado)) {&#10;                    Celda vecino = laberinto.getCelda(nuevaFila, nuevaColumna);&#10;                    visitado[nuevaFila][nuevaColumna] = true;&#10;                    predecesor[nuevaFila][nuevaColumna] = actual;&#10;                    pila.push(vecino);&#10;                    this.recorrido.add(vecino); // Añadir la celda visitada al recorrido&#10;                }&#10;            }&#10;        }&#10;        return Collections.emptyList(); // No se encontró ruta&#10;    }&#10;&#10;    /**&#10;     * Reconstruye la ruta desde el destino hasta el inicio usando el arreglo de predecesores.&#10;     */&#10;    private List&lt;Celda&gt; reconstruirRuta(Celda[][] predecesor, Celda inicio, Celda fin) {&#10;        List&lt;Celda&gt; ruta = new ArrayList&lt;&gt;();&#10;        for (Celda at = fin; at != null; at = predecesor[at.getFila()][at.getColumna()]) {&#10;            ruta.add(at);&#10;        }&#10;        Collections.reverse(ruta);&#10;        return ruta;&#10;    }&#10;&#10;    /**&#10;     * Verifica si una celda es válida para el movimiento.&#10;     */&#10;    private boolean esValido(Laberinto laberinto, int fila, int columna, boolean[][] visitado) {&#10;        int filas = laberinto.getFilas();&#10;        int columnas = laberinto.getColumnas();&#10;        if (fila &lt; 0 || fila &gt;= filas || columna &lt; 0 || columna &gt;= columnas) {&#10;            return false;&#10;        }&#10;        if (visitado[fila][columna] || !laberinto.getCelda(fila, columna).esTransitable()) {&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/modelo/SolverRecursivo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/modelo/SolverRecursivo.java" />
              <option name="originalContent" value="package modelo;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Clase que implementa algoritmos recursivos (backtracking) para encontrar&#10; * rutas en un laberinto. Ha sido refactorizada para manejar correctamente el&#10; * estado y registrar todas las celdas visitadas durante la exploración.&#10; *&#10; * @version 1.1&#10; */&#10;public class SolverRecursivo {&#10;&#10;    // Movimientos para 2 direcciones: derecha y abajo&#10;    private static final int[] dx2 = {0, 1};&#10;    private static final int[] dy2 = {1, 0};&#10;&#10;    // Movimientos para 4 direcciones: derecha, izquierda, abajo, arriba&#10;    private static final int[] dx4 = {0, 0, 1, -1};&#10;    private static final int[] dy4 = {1, -1, 0, 0};&#10;&#10;    // --- Variables de estado para una única ejecución ---&#10;    private boolean[][] visitado;&#10;    private List&lt;int[]&gt; rutaActual;&#10;    private List&lt;int[]&gt; mejorRuta;&#10;    private List&lt;int[]&gt; celdasVisitadas; // Guarda TODAS las celdas exploradas&#10;&#10;    /**&#10;     * Inicializa las variables de estado antes de cada búsqueda.&#10;     * Es crucial para asegurar que cada llamada a 'resolver' sea independiente.&#10;     *&#10;     * @param laberinto La matriz del laberinto para determinar las dimensiones.&#10;     */&#10;    private void inicializar(int[][] laberinto) {&#10;        this.visitado = new boolean[laberinto.length][laberinto[0].length];&#10;        this.rutaActual = new ArrayList&lt;&gt;();&#10;        this.mejorRuta = new ArrayList&lt;&gt;();&#10;        this.celdasVisitadas = new ArrayList&lt;&gt;(); // ¡Importante inicializar aquí!&#10;    }&#10;&#10;    /**&#10;     * Devuelve la lista de todas las celdas que fueron exploradas durante la última&#10;     * ejecución del algoritmo.&#10;     *&#10;     * @return Una lista de coordenadas [fila, columna].&#10;     */&#10;    public List&lt;int[]&gt; getCeldasVisitadas() {&#10;        return this.celdasVisitadas;&#10;    }&#10;&#10;    /**&#10;     * Resuelve el laberinto usando backtracking con solo 2 direcciones (abajo y derecha).&#10;     * Encuentra la única ruta posible si existe.&#10;     */&#10;    public List&lt;int[]&gt; resolver2Direcciones(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        if (finFila &lt; fila || finCol &lt; col) {&#10;            return mejorRuta; // Imposible llegar&#10;        }&#10;        backtrack(laberinto, fila, col, finFila, finCol, dx2, dy2);&#10;        return mejorRuta;&#10;    }&#10;&#10;    /**&#10;     * Resuelve el laberinto usando backtracking con 4 direcciones.&#10;     * Esto encontrará una ruta, pero no necesariamente la más corta.&#10;     */&#10;    public List&lt;int[]&gt; resolver4Direcciones(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        backtrack(laberinto, fila, col, finFila, finCol, dx4, dy4);&#10;        return mejorRuta;&#10;    }&#10;&#10;    /**&#10;     * Resuelve el laberinto usando backtracking completo para encontrar la ruta más corta.&#10;     * Explora todas las posibilidades.&#10;     */&#10;    public List&lt;int[]&gt; resolverBacktracking(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        backtrack(laberinto, fila, col, finFila, finCol, dx4, dy4);&#10;        return mejorRuta;&#10;    }&#10;&#10;    /**&#10;     * Método de backtracking genérico que explora el laberinto.&#10;     *&#10;     * @param lab      La matriz del laberinto.&#10;     * @param x        Fila actual.&#10;     * @param y        Columna actual.&#10;     * @param finX     Fila de destino.&#10;     * @param finY     Columna de destino.&#10;     * @param movesX   Array de movimientos en X.&#10;     * @param movesY   Array de movimientos en Y.&#10;     */&#10;    private void backtrack(int[][] lab, int x, int y, int finX, int finY, int[] movesX, int[] movesY) {&#10;        // Condición de parada: fuera de límites, es un muro o ya se visitó en esta ruta.&#10;        if (!esValido(lab, x, y) || visitado[x][y]) {&#10;            return;&#10;        }&#10;&#10;        // --- Acción ---&#10;        visitado[x][y] = true;&#10;        rutaActual.add(new int[]{x, y});&#10;        celdasVisitadas.add(new int[]{x, y}); // Registra la celda como explorada&#10;&#10;        // Si llegamos al destino&#10;        if (x == finX &amp;&amp; y == finY) {&#10;            // Si es la primera ruta encontrada o si es más corta que la anterior&#10;            if (mejorRuta.isEmpty() || rutaActual.size() &lt; mejorRuta.size()) {&#10;                mejorRuta = new ArrayList&lt;&gt;(rutaActual);&#10;            }&#10;        } else {&#10;            // --- Recursión ---&#10;            // Explorar todos los vecinos posibles según los movimientos permitidos&#10;            for (int i = 0; i &lt; movesX.length; i++) {&#10;                // Poda: Si la ruta actual ya es más larga que la mejor encontrada, no seguir.&#10;                // Esto es clave para la eficiencia en el backtracking completo.&#10;                if (mejorRuta.isEmpty() || rutaActual.size() &lt; mejorRuta.size()) {&#10;                    backtrack(lab, x + movesX[i], y + movesY[i], finX, finY, movesX, movesY);&#10;                }&#10;            }&#10;        }&#10;&#10;        // --- Backtrack (deshacer) ---&#10;        // Liberamos la celda para que pueda ser parte de otras rutas posibles.&#10;        visitado[x][y] = false;&#10;        rutaActual.remove(rutaActual.size() - 1);&#10;    }&#10;&#10;    /**&#10;     * Verifica si una celda es transitable (dentro de los límites y no es un muro).&#10;     */&#10;    private boolean esValido(int[][] lab, int x, int y) {&#10;        return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; lab.length &amp;&amp; y &lt; lab[0].length &amp;&amp; lab[x][y] == 1;&#10;    }&#10;}" />
              <option name="updatedContent" value="package modelo;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Implementa soluciones recursivas para encontrar caminos en el laberinto.&#10; * Incluye tres variantes de algoritmos recursivos:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Recursivo de 2 direcciones (solo derecha y abajo)&lt;/li&gt;&#10; *   &lt;li&gt;Recursivo de 4 direcciones (todas las direcciones)&lt;/li&gt;&#10; *   &lt;li&gt;Backtracking con optimización para encontrar el camino más corto&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * Características principales:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Usa técnicas de backtracking para explorar caminos&lt;/li&gt;&#10; *   &lt;li&gt;Implementa poda para optimizar la búsqueda&lt;/li&gt;&#10; *   &lt;li&gt;Mantiene registro de celdas visitadas para evitar ciclos&lt;/li&gt;&#10; *   &lt;li&gt;Incluye versión con memoización para mejorar rendimiento&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @author Israel Orellana&#10; * @version 2.0&#10; */&#10;public class SolverRecursivo {&#10;&#10;    // Movimientos para 2 direcciones: derecha y abajo&#10;    private static final int[] dx2 = {0, 1};&#10;    private static final int[] dy2 = {1, 0};&#10;&#10;    // Movimientos para 4 direcciones: derecha, izquierda, abajo, arriba&#10;    private static final int[] dx4 = {0, 0, 1, -1};&#10;    private static final int[] dy4 = {1, -1, 0, 0};&#10;&#10;    // --- Variables de estado para una única ejecución ---&#10;    private boolean[][] visitado;&#10;    private List&lt;int[]&gt; rutaActual;&#10;    private List&lt;int[]&gt; mejorRuta;&#10;    private List&lt;int[]&gt; celdasVisitadas; // Guarda TODAS las celdas exploradas&#10;&#10;    /**&#10;     * Inicializa las variables de estado antes de cada búsqueda.&#10;     * Es crucial para asegurar que cada llamada a 'resolver' sea independiente.&#10;     *&#10;     * @param laberinto La matriz del laberinto para determinar las dimensiones.&#10;     */&#10;    private void inicializar(int[][] laberinto) {&#10;        this.visitado = new boolean[laberinto.length][laberinto[0].length];&#10;        this.rutaActual = new ArrayList&lt;&gt;();&#10;        this.mejorRuta = new ArrayList&lt;&gt;();&#10;        this.celdasVisitadas = new ArrayList&lt;&gt;(); // ¡Importante inicializar aquí!&#10;    }&#10;&#10;    /**&#10;     * Devuelve la lista de todas las celdas que fueron exploradas durante la última&#10;     * ejecución del algoritmo.&#10;     *&#10;     * @return Una lista de coordenadas [fila, columna].&#10;     */&#10;    public List&lt;int[]&gt; getCeldasVisitadas() {&#10;        return this.celdasVisitadas;&#10;    }&#10;&#10;    /**&#10;     * Resuelve el laberinto usando backtracking con solo 2 direcciones (abajo y derecha).&#10;     * Encuentra la única ruta posible si existe.&#10;     */&#10;    public List&lt;int[]&gt; resolver2Direcciones(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        if (finFila &lt; fila || finCol &lt; col) {&#10;            return mejorRuta; // Imposible llegar&#10;        }&#10;        backtrack(laberinto, fila, col, finFila, finCol, dx2, dy2);&#10;        return mejorRuta;&#10;    }&#10;&#10;    /**&#10;     * Resuelve el laberinto usando backtracking con 4 direcciones.&#10;     * Esto encontrará una ruta, pero no necesariamente la más corta.&#10;     */&#10;    public List&lt;int[]&gt; resolver4Direcciones(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        backtrack(laberinto, fila, col, finFila, finCol, dx4, dy4);&#10;        return mejorRuta;&#10;    }&#10;&#10;    /**&#10;     * Resuelve el laberinto usando backtracking completo para encontrar la ruta más corta.&#10;     * Explora todas las posibilidades.&#10;     */&#10;    public List&lt;int[]&gt; resolverBacktracking(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        backtrack(laberinto, fila, col, finFila, finCol, dx4, dy4);&#10;        return mejorRuta;&#10;    }&#10;&#10;    /**&#10;     * Método de backtracking genérico que explora el laberinto.&#10;     *&#10;     * @param lab      La matriz del laberinto.&#10;     * @param x        Fila actual.&#10;     * @param y        Columna actual.&#10;     * @param finX     Fila de destino.&#10;     * @param finY     Columna de destino.&#10;     * @param movesX   Array de movimientos en X.&#10;     * @param movesY   Array de movimientos en Y.&#10;     */&#10;    private void backtrack(int[][] lab, int x, int y, int finX, int finY, int[] movesX, int[] movesY) {&#10;        // Condición de parada: fuera de límites, es un muro o ya se visitó en esta ruta.&#10;        if (!esValido(lab, x, y) || visitado[x][y]) {&#10;            return;&#10;        }&#10;&#10;        // --- Acción ---&#10;        visitado[x][y] = true;&#10;        rutaActual.add(new int[]{x, y});&#10;        celdasVisitadas.add(new int[]{x, y}); // Registra la celda como explorada&#10;&#10;        // Si llegamos al destino&#10;        if (x == finX &amp;&amp; y == finY) {&#10;            // Si es la primera ruta encontrada o si es más corta que la anterior&#10;            if (mejorRuta.isEmpty() || rutaActual.size() &lt; mejorRuta.size()) {&#10;                mejorRuta = new ArrayList&lt;&gt;(rutaActual);&#10;            }&#10;        } else {&#10;            // --- Recursión ---&#10;            // Explorar todos los vecinos posibles según los movimientos permitidos&#10;            for (int i = 0; i &lt; movesX.length; i++) {&#10;                // Poda: Si la ruta actual ya es más larga que la mejor encontrada, no seguir.&#10;                // Esto es clave para la eficiencia en el backtracking completo.&#10;                if (mejorRuta.isEmpty() || rutaActual.size() &lt; mejorRuta.size()) {&#10;                    backtrack(lab, x + movesX[i], y + movesY[i], finX, finY, movesX, movesY);&#10;                }&#10;            }&#10;        }&#10;&#10;        // --- Backtrack (deshacer) ---&#10;        // Liberamos la celda para que pueda ser parte de otras rutas posibles.&#10;        visitado[x][y] = false;&#10;        rutaActual.remove(rutaActual.size() - 1);&#10;    }&#10;&#10;    /**&#10;     * Verifica si una celda es transitable (dentro de los límites y no es un muro).&#10;     */&#10;    private boolean esValido(int[][] lab, int x, int y) {&#10;        return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; lab.length &amp;&amp; y &lt; lab[0].length &amp;&amp; lab[x][y] == 1;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vista/ControlPanel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vista/ControlPanel.java" />
              <option name="originalContent" value="package vista;&#10;&#10;import javax.swing.*;&#10;import javax.swing.border.TitledBorder;&#10;import java.awt.*;&#10;import java.awt.event.ActionListener;&#10;&#10;/**&#10; * Panel de control que contiene todos los elementos interactivos de la interfaz.&#10; * Gestiona la configuración del laberinto y los controles de algoritmos.&#10; *&#10; * Componentes principales:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Selector de tamaño del laberinto (filas y columnas)&lt;/li&gt;&#10; *   &lt;li&gt;Selector de algoritmo a utilizar&lt;/li&gt;&#10; *   &lt;li&gt;Botones de acción (resolver, mostrar camino, paso a paso)&lt;/li&gt;&#10; *   &lt;li&gt;Área de resultados para mostrar estadísticas&lt;/li&gt;&#10; *   &lt;li&gt;Botón de limpieza general&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @version 2.0&#10; */&#10;public class ControlPanel extends JPanel {&#10;    private JComboBox&lt;String&gt; algorithmSelector;&#10;    private JTextArea resultsArea;&#10;    private JTextField rowsField;&#10;    private JTextField colsField;&#10;    private JButton generateButton;&#10;&#10;    private JButton solveButton;&#10;    private JButton showFullPathButton;&#10;    private JButton stepByStepButton;&#10;    private JButton clearAllButton;&#10;&#10;    /**&#10;     * Construye el panel de control, inicializando y organizando todos&#10;     * sus componentes de interfaz.&#10;     */&#10;    public ControlPanel() {&#10;        // Configuración del layout principal del panel&#10;        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));&#10;        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));&#10;        setPreferredSize(new Dimension(250, 0)); // Un poco más ancho para el texto de los botones&#10;&#10;        // --- Panel de configuración ---&#10;        JPanel configPanel = new JPanel(new GridLayout(0, 2, 5, 5));&#10;        configPanel.setBorder(new TitledBorder(&quot;Configuración&quot;));&#10;&#10;        rowsField = new JTextField(&quot;5&quot;);&#10;        colsField = new JTextField(&quot;5&quot;);&#10;        generateButton = new JButton(&quot;Generar/Limpiar&quot;);&#10;&#10;        configPanel.add(new JLabel(&quot;Filas:&quot;));&#10;        configPanel.add(rowsField);&#10;        configPanel.add(new JLabel(&quot;Columnas:&quot;));&#10;        configPanel.add(colsField);&#10;        configPanel.add(generateButton);&#10;        configPanel.add(new JLabel()); // Espacio vacío para alinear&#10;        add(configPanel);&#10;&#10;        add(Box.createRigidArea(new Dimension(0, 20)));&#10;&#10;        // --- Panel de selección de algoritmo y acciones ---&#10;        JPanel algoPanel = new JPanel(new BorderLayout(5, 5));&#10;        algoPanel.setBorder(new TitledBorder(&quot;Algoritmo y Acciones&quot;));&#10;        String[] algorithms = {&quot;BFS&quot;, &quot;DFS&quot;, &quot;Recursivo (2 dir)&quot;, &quot;Recursivo (4 dir)&quot;, &quot;Backtracking&quot;};&#10;        algorithmSelector = new JComboBox&lt;&gt;(algorithms);&#10;        algoPanel.add(algorithmSelector, BorderLayout.NORTH);&#10;&#10;        // --- Panel para agrupar los tres botones de acción ---&#10;        JPanel actionButtonsPanel = new JPanel(new GridLayout(0, 1, 5, 5)); // Layout para apilar botones&#10;        solveButton = new JButton(&quot;¡Resolver!&quot;); // Botón original&#10;        showFullPathButton = new JButton(&quot;Mostrar Camino Completo&quot;);&#10;        stepByStepButton = new JButton(&quot;Resolver Paso a Paso&quot;);&#10;        clearAllButton = new JButton(&quot;Borrar Todo&quot;);&#10;&#10;        actionButtonsPanel.add(solveButton);&#10;        actionButtonsPanel.add(showFullPathButton);&#10;        actionButtonsPanel.add(stepByStepButton);&#10;        actionButtonsPanel.add(clearAllButton);&#10;&#10;        algoPanel.add(actionButtonsPanel, BorderLayout.CENTER); // Se añaden al centro&#10;&#10;        add(algoPanel);&#10;&#10;        add(Box.createRigidArea(new Dimension(0, 20)));&#10;&#10;        // --- Panel de resultados ---&#10;        JPanel resultsPanel = new JPanel(new BorderLayout());&#10;        resultsPanel.setBorder(new TitledBorder(&quot;Resultados&quot;));&#10;        resultsArea = new JTextArea(10, 15);&#10;        resultsArea.setEditable(false);&#10;        resultsPanel.add(new JScrollPane(resultsArea));&#10;        add(resultsPanel);&#10;    }&#10;&#10;    // --- Métodos públicos para que otros (la Vista o el Controlador) interactúen con este panel ---&#10;&#10;    /**&#10;     * Obtiene el número de filas introducido por el usuario.&#10;     *&#10;     * @return El número de filas como un entero. Devuelve 20 si la entrada es inválida.&#10;     * @return El número de filas como un entero.&#10;     */&#10;    public int getRows() {&#10;        try {&#10;            return Integer.parseInt(rowsField.getText());&#10;        } catch (NumberFormatException e) {&#10;            return 20; // Valor por defecto si la entrada es inválida&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el número de columnas introducido por el usuario.&#10;     *&#10;     * @return El número de columnas como un entero. Devuelve 20 si la entrada es inválida.&#10;     * @return El número de columnas como un entero.&#10;     */&#10;    public int getCols() {&#10;        try {&#10;            return Integer.parseInt(colsField.getText());&#10;        } catch (NumberFormatException e) {&#10;            return 20; // Valor por defecto&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el nombre del algoritmo seleccionado por el usuario en el JComboBox.&#10;     *&#10;     * Obtiene el nombre del algoritmo seleccionado por el usuario.&#10;     * @return El algoritmo seleccionado como un String.&#10;     */&#10;    public String getSelectedAlgorithm() {&#10;        return (String) algorithmSelector.getSelectedItem();&#10;    }&#10;&#10;    /**&#10;     * Establece el texto que se mostrará en el área de resultados.&#10;     *&#10;     * @param text El texto a mostrar.&#10;     */&#10;    public void setResultsText(String text) {&#10;        resultsArea.setText(text);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Generar/Limpiar&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar cuando se presiona el botón.&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addGenerateListener(ActionListener listener) {&#10;        generateButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;¡Resolver!&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addSolveListener(ActionListener listener) {&#10;        solveButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Mostrar Camino Completo&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addShowFullPathListener(ActionListener listener) {&#10;        showFullPathButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Resolver Paso a Paso&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addStepByStepListener(ActionListener listener) {&#10;        stepByStepButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Borrar Todo&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addClearAllListener(ActionListener listener) {&#10;        clearAllButton.addActionListener(listener);&#10;    }&#10;}" />
              <option name="updatedContent" value="package vista;&#10;&#10;import javax.swing.*;&#10;import javax.swing.border.TitledBorder;&#10;import java.awt.*;&#10;import java.awt.event.ActionListener;&#10;&#10;/**&#10; * Panel de control que contiene todos los elementos interactivos de la interfaz.&#10; * Gestiona la configuración del laberinto y los controles de algoritmos.&#10; *&#10; * Componentes principales:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Selector de tamaño del laberinto (filas y columnas)&lt;/li&gt;&#10; *   &lt;li&gt;Selector de algoritmo a utilizar&lt;/li&gt;&#10; *   &lt;li&gt;Botones de acción (resolver, mostrar camino, paso a paso)&lt;/li&gt;&#10; *   &lt;li&gt;Área de resultados para mostrar estadísticas&lt;/li&gt;&#10; *   &lt;li&gt;Botón de limpieza general&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @version 2.0&#10; */&#10;public class ControlPanel extends JPanel {&#10;    private JComboBox&lt;String&gt; algorithmSelector;&#10;    private JTextArea resultsArea;&#10;    private JTextField rowsField;&#10;    private JTextField colsField;&#10;    private JButton generateButton;&#10;&#10;    private JButton solveButton;&#10;    private JButton showFullPathButton;&#10;    private JButton stepByStepButton;&#10;    private JButton clearAllButton;&#10;&#10;    /**&#10;     * Construye el panel de control, inicializando y organizando todos&#10;     * sus componentes de interfaz.&#10;     */&#10;    public ControlPanel() {&#10;        // Configuración del layout principal del panel&#10;        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));&#10;        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));&#10;        setPreferredSize(new Dimension(250, 600)); // Aumentamos la altura preferida&#10;&#10;        // --- Panel de configuración ---&#10;        JPanel configPanel = new JPanel(new GridLayout(0, 2, 5, 5));&#10;        configPanel.setBorder(new TitledBorder(&quot;Configuración&quot;));&#10;&#10;        rowsField = new JTextField(&quot;5&quot;);&#10;        colsField = new JTextField(&quot;5&quot;);&#10;        generateButton = new JButton(&quot;Generar/Limpiar&quot;);&#10;&#10;        configPanel.add(new JLabel(&quot;Filas:&quot;));&#10;        configPanel.add(rowsField);&#10;        configPanel.add(new JLabel(&quot;Columnas:&quot;));&#10;        configPanel.add(colsField);&#10;        configPanel.add(generateButton);&#10;        configPanel.add(new JLabel()); // Espacio vacío para alinear&#10;        add(configPanel);&#10;&#10;        add(Box.createRigidArea(new Dimension(0, 10)));&#10;&#10;        // --- Panel de selección de algoritmo y acciones ---&#10;        JPanel algoPanel = new JPanel(new BorderLayout(5, 5));&#10;        algoPanel.setBorder(new TitledBorder(&quot;Algoritmo y Acciones&quot;));&#10;        String[] algorithms = {&quot;BFS&quot;, &quot;DFS&quot;, &quot;Recursivo (2 dir)&quot;, &quot;Recursivo (4 dir)&quot;, &quot;Backtracking&quot;};&#10;        algorithmSelector = new JComboBox&lt;&gt;(algorithms);&#10;        algoPanel.add(algorithmSelector, BorderLayout.NORTH);&#10;&#10;        // --- Panel para agrupar los botones de acción ---&#10;        JPanel actionButtonsPanel = new JPanel(new GridLayout(0, 1, 5, 5));&#10;        solveButton = new JButton(&quot;¡Resolver!&quot;);&#10;        showFullPathButton = new JButton(&quot;Mostrar Camino Completo&quot;);&#10;        stepByStepButton = new JButton(&quot;Resolver Paso a Paso&quot;);&#10;        clearAllButton = new JButton(&quot;Borrar Todo&quot;);&#10;&#10;        actionButtonsPanel.add(solveButton);&#10;        actionButtonsPanel.add(showFullPathButton);&#10;        actionButtonsPanel.add(stepByStepButton);&#10;        actionButtonsPanel.add(clearAllButton);&#10;&#10;        algoPanel.add(actionButtonsPanel, BorderLayout.CENTER);&#10;        add(algoPanel);&#10;&#10;        add(Box.createRigidArea(new Dimension(0, 10)));&#10;&#10;        // --- Panel de resultados con scroll ---&#10;        JPanel resultsPanel = new JPanel(new BorderLayout());&#10;        resultsPanel.setBorder(new TitledBorder(&quot;Resultados&quot;));&#10;        resultsArea = new JTextArea(8, 15); // Aumentamos las filas visibles&#10;        resultsArea.setEditable(false);&#10;        resultsArea.setLineWrap(true);&#10;        resultsArea.setWrapStyleWord(true);&#10;        JScrollPane scrollPane = new JScrollPane(resultsArea);&#10;        scrollPane.setPreferredSize(new Dimension(200, 150)); // Aseguramos un tamaño mínimo&#10;        resultsPanel.add(scrollPane);&#10;        add(resultsPanel);&#10;&#10;        // Añadimos un panel de relleno que puede expandirse&#10;        add(Box.createVerticalGlue());&#10;    }&#10;&#10;    // --- Métodos públicos para que otros (la Vista o el Controlador) interactúen con este panel ---&#10;&#10;    /**&#10;     * Obtiene el número de filas introducido por el usuario.&#10;     *&#10;     * @return El número de filas como un entero. Devuelve 20 si la entrada es inválida.&#10;     * @return El número de filas como un entero.&#10;     */&#10;    public int getRows() {&#10;        try {&#10;            return Integer.parseInt(rowsField.getText());&#10;        } catch (NumberFormatException e) {&#10;            return 20; // Valor por defecto si la entrada es inválida&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el número de columnas introducido por el usuario.&#10;     *&#10;     * @return El número de columnas como un entero. Devuelve 20 si la entrada es inválida.&#10;     * @return El número de columnas como un entero.&#10;     */&#10;    public int getCols() {&#10;        try {&#10;            return Integer.parseInt(colsField.getText());&#10;        } catch (NumberFormatException e) {&#10;            return 20; // Valor por defecto&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el nombre del algoritmo seleccionado por el usuario en el JComboBox.&#10;     *&#10;     * Obtiene el nombre del algoritmo seleccionado por el usuario.&#10;     * @return El algoritmo seleccionado como un String.&#10;     */&#10;    public String getSelectedAlgorithm() {&#10;        return (String) algorithmSelector.getSelectedItem();&#10;    }&#10;&#10;    /**&#10;     * Establece el texto que se mostrará en el área de resultados.&#10;     *&#10;     * @param text El texto a mostrar.&#10;     */&#10;    public void setResultsText(String text) {&#10;        resultsArea.setText(text);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Generar/Limpiar&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar cuando se presiona el botón.&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addGenerateListener(ActionListener listener) {&#10;        generateButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;¡Resolver!&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addSolveListener(ActionListener listener) {&#10;        solveButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Mostrar Camino Completo&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addShowFullPathListener(ActionListener listener) {&#10;        showFullPathButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Resolver Paso a Paso&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addStepByStepListener(ActionListener listener) {&#10;        stepByStepButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Borrar Todo&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addClearAllListener(ActionListener listener) {&#10;        clearAllButton.addActionListener(listener);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vista/MazePanel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vista/MazePanel.java" />
              <option name="originalContent" value="package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.MouseAdapter;&#10;import java.awt.event.MouseEvent;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * MazePanel es un JPanel personalizado que representa visualmente un laberinto.&#10; * Permite la interacción del usuario para definir muros, punto de inicio y fin,&#10; * y muestra rutas de solución y animaciones paso a paso.&#10; *&#10; * Funcionalidades principales:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Dibujo de celdas transitables y muros.&lt;/li&gt;&#10; *   &lt;li&gt;Selección de punto de inicio (clic derecho) y fin (Shift + clic izquierdo).&lt;/li&gt;&#10; *   &lt;li&gt;Colocación y eliminación de muros (clic izquierdo).&lt;/li&gt;&#10; *   &lt;li&gt;Visualización de rutas de solución y nodos visitados.&lt;/li&gt;&#10; *   &lt;li&gt;Animación paso a paso de la solución.&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @version 1.2 - Añadida lógica para visualización completa y paso a paso manual.&#10; */&#10;public class MazePanel extends JPanel {&#10;    private int rows;&#10;    private int cols;&#10;    private int[][] mazeData;&#10;    private Point startPoint;&#10;    private Point endPoint;&#10;&#10;    // --- Atributos para la visualización ---&#10;    private List&lt;int[]&gt; visitedNodes; // Nodos visitados (gris)&#10;    private List&lt;int[]&gt; finalPath;    // Camino final (azul)&#10;&#10;    // --- NUEVO: Atributos para la animación paso a paso ---&#10;    private List&lt;int[]&gt; stepByStepPathToAnimate; // La ruta completa a animar&#10;    private int stepByStepCurrentIndex;      // El índice del paso actual&#10;&#10;    private final int CELL_SIZE = 25;&#10;&#10;    public MazePanel(int rows, int cols) {&#10;        this.rows = rows;&#10;        this.cols = cols;&#10;        this.mazeData = new int[rows][cols];&#10;        this.visitedNodes = new ArrayList&lt;&gt;();&#10;        this.finalPath = new ArrayList&lt;&gt;();&#10;        clearMaze();&#10;        setPreferredSize(new Dimension(cols * CELL_SIZE, rows * CELL_SIZE));&#10;        addMouseListeners();&#10;    }&#10;&#10;    private void addMouseListeners() {&#10;        addMouseListener(new MouseAdapter() {&#10;            @Override&#10;            public void mousePressed(MouseEvent e) {&#10;                int col = e.getX() / CELL_SIZE;&#10;                int row = e.getY() / CELL_SIZE;&#10;                if (row &gt;= rows || col &gt;= cols) return;&#10;                // Solo permitir inicio/fin en celdas transitables&#10;                if (e.isShiftDown() &amp;&amp; SwingUtilities.isLeftMouseButton(e)) {&#10;                    if (mazeData[row][col] == 1) {&#10;                        endPoint = new Point(col, row);&#10;                    } else {&#10;                        JOptionPane.showMessageDialog(MazePanel.this, &quot;El punto de fin debe estar en una celda transitable.&quot;, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    }&#10;                } else if (SwingUtilities.isRightMouseButton(e)) {&#10;                    if (mazeData[row][col] == 1) {&#10;                        startPoint = new Point(col, row);&#10;                    } else {&#10;                        JOptionPane.showMessageDialog(MazePanel.this, &quot;El punto de inicio debe estar en una celda transitable.&quot;, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    }&#10;                } else if (SwingUtilities.isLeftMouseButton(e)) {&#10;                    mazeData[row][col] = (mazeData[row][col] == 1) ? 0 : 1;&#10;                }&#10;                repaint();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        Graphics2D g2d = (Graphics2D) g;&#10;&#10;        // 1. Dibuja las celdas base (muros y caminos)&#10;        for (int row = 0; row &lt; rows; row++) {&#10;            for (int col = 0; col &lt; cols; col++) {&#10;                g2d.setColor(mazeData[row][col] == 0 ? Color.BLACK : Color.WHITE);&#10;                g2d.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 2. Dibuja los nodos visitados (en gris claro)&#10;        g2d.setColor(new Color(220, 220, 220)); // Un gris más claro&#10;        for (int[] node : visitedNodes) {&#10;            g2d.fillRect(node[1] * CELL_SIZE, node[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;        }&#10;&#10;        // 3. Dibuja el camino final completo (si está activo)&#10;        g2d.setColor(new Color(66, 135, 245)); // Un azul claro&#10;        for (int[] step : finalPath) {&#10;            g2d.fillRect(step[1] * CELL_SIZE, step[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;        }&#10;&#10;        // 4. Dibuja la animación paso a paso (si está activa)&#10;        if (stepByStepPathToAnimate != null &amp;&amp; !stepByStepPathToAnimate.isEmpty()) {&#10;            g2d.setColor(new Color(255, 165, 0)); // Naranja para destacar el paso a paso&#10;            // Dibuja solo los pasos hasta el índice actual&#10;            for (int i = 0; i &lt;= stepByStepCurrentIndex &amp;&amp; i &lt; stepByStepPathToAnimate.size(); i++) {&#10;                int[] step = stepByStepPathToAnimate.get(i);&#10;                g2d.fillRect(step[1] * CELL_SIZE, step[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 5. Dibuja la cuadrícula&#10;        g2d.setColor(Color.GRAY);&#10;        for (int row = 0; row &lt; rows; row++) {&#10;            for (int col = 0; col &lt; cols; col++) {&#10;                g2d.drawRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 6. Dibuja los puntos de inicio y fin encima de todo&#10;        if (startPoint != null) {&#10;            g2d.setColor(Color.GREEN);&#10;            g2d.fillRect(startPoint.x * CELL_SIZE, startPoint.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.drawString(&quot;A&quot;, startPoint.x * CELL_SIZE + 8, startPoint.y * CELL_SIZE + 18);&#10;        }&#10;        if (endPoint != null) {&#10;            g2d.setColor(Color.RED);&#10;            g2d.fillRect(endPoint.x * CELL_SIZE, endPoint.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            g2d.setColor(Color.WHITE);&#10;            g2d.drawString(&quot;B&quot;, endPoint.x * CELL_SIZE + 8, endPoint.y * CELL_SIZE + 18);&#10;        }&#10;    }&#10;&#10;    public void clearMaze() {&#10;        for (int i = 0; i &lt; rows; i++) {&#10;            for (int j = 0; j &lt; cols; j++) {&#10;                mazeData[i][j] = 1;&#10;            }&#10;        }&#10;        startPoint = null;&#10;        endPoint = null;&#10;        clearVisuals();&#10;        repaint();&#10;    }&#10;&#10;    public void clearVisuals() {&#10;        visitedNodes.clear();&#10;        finalPath.clear();&#10;        // --- NUEVO: Limpiar estado de paso a paso ---&#10;        stepByStepPathToAnimate = null;&#10;        stepByStepCurrentIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    // --- MÉTODOS PÚBLICOS PARA LOS MODOS DE DIBUJO ---&#10;&#10;    /**&#10;     * Dibuja instantáneamente solo la ruta de la solución final.&#10;     * Usado por el botón &quot;¡Resolver!&quot;.&#10;     */&#10;    public void drawSimplePath(List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Dibuja instantáneamente todos los nodos visitados y la ruta final.&#10;     * Usado por el botón &quot;Mostrar Camino Completo&quot;.&#10;     */&#10;    public void drawFullPath(List&lt;int[]&gt; visited, List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (visited != null) {&#10;            this.visitedNodes = new ArrayList&lt;&gt;(visited);&#10;        }&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Prepara el panel para la animación paso a paso, pero no la inicia.&#10;     * Guarda la ruta y reinicia el contador.&#10;     */&#10;    public void prepareForStepByStep(List&lt;int[]&gt; path) {&#10;        clearVisuals(); // Limpia cualquier dibujo anterior&#10;        if (path != null &amp;&amp; !path.isEmpty()) {&#10;            this.stepByStepPathToAnimate = new ArrayList&lt;&gt;(path);&#10;            this.stepByStepCurrentIndex = -1; // Empezamos antes del primer paso&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Avanza un paso en la animación y redibuja el panel.&#10;     * Usado por el botón &quot;Resolver Paso a Paso&quot;.&#10;     */&#10;    public void nextStep() {&#10;        if (stepByStepPathToAnimate != null &amp;&amp; stepByStepCurrentIndex &lt; stepByStepPathToAnimate.size() - 1) {&#10;            stepByStepCurrentIndex++;&#10;            repaint();&#10;        }&#10;    }&#10;&#10;    // --- Getters y Setters (sin cambios) ---&#10;    public void setMazeData(int[][] mazeData) {&#10;        if (mazeData == null || mazeData.length == 0) return;&#10;        this.rows = mazeData.length;&#10;        this.cols = mazeData[0].length;&#10;        this.mazeData = mazeData;&#10;        setPreferredSize(new Dimension(cols * CELL_SIZE, rows * CELL_SIZE));&#10;        revalidate();&#10;        repaint();&#10;    }&#10;&#10;    public int[][] getMazeData() { return mazeData; }&#10;    public Point getStartPoint() { return startPoint; }&#10;    public Point getEndPoint() { return endPoint; }&#10;}" />
              <option name="updatedContent" value="package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.MouseAdapter;&#10;import java.awt.event.MouseEvent;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * MazePanel es un JPanel personalizado que representa visualmente un laberinto.&#10; * Permite la interacción del usuario para definir muros, punto de inicio y fin,&#10; * y muestra rutas de solución y animaciones paso a paso.&#10; *&#10; * Funcionalidades principales:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Dibujo de celdas transitables y muros.&lt;/li&gt;&#10; *   &lt;li&gt;Selección de punto de inicio (clic derecho) y fin (Shift + clic izquierdo).&lt;/li&gt;&#10; *   &lt;li&gt;Colocación y eliminación de muros (clic izquierdo).&lt;/li&gt;&#10; *   &lt;li&gt;Visualización de rutas de solución y nodos visitados.&lt;/li&gt;&#10; *   &lt;li&gt;Animación paso a paso de la solución.&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @version 1.2 - Añadida lógica para visualización completa y paso a paso manual.&#10; */&#10;public class MazePanel extends JPanel {&#10;    private int rows;&#10;    private int cols;&#10;    private int[][] mazeData;&#10;    private Point startPoint;&#10;    private Point endPoint;&#10;&#10;    // --- Atributos para la visualización ---&#10;    private List&lt;int[]&gt; visitedNodes; // Nodos visitados (gris)&#10;    private List&lt;int[]&gt; finalPath;    // Camino final (azul)&#10;&#10;    // --- NUEVO: Atributos para la animación paso a paso ---&#10;    private List&lt;int[]&gt; stepByStepPathToAnimate; // La ruta completa a animar&#10;    private int stepByStepCurrentIndex;      // El índice del paso actual&#10;&#10;    private final int CELL_SIZE = 25;&#10;&#10;    public MazePanel(int rows, int cols) {&#10;        this.rows = rows;&#10;        this.cols = cols;&#10;        this.mazeData = new int[rows][cols];&#10;        this.visitedNodes = new ArrayList&lt;&gt;();&#10;        this.finalPath = new ArrayList&lt;&gt;();&#10;        clearMaze();&#10;        setPreferredSize(new Dimension(cols * CELL_SIZE, rows * CELL_SIZE));&#10;        addMouseListeners();&#10;    }&#10;&#10;    private void addMouseListeners() {&#10;        addMouseListener(new MouseAdapter() {&#10;            @Override&#10;            public void mousePressed(MouseEvent e) {&#10;                int col = e.getX() / CELL_SIZE;&#10;                int row = e.getY() / CELL_SIZE;&#10;                if (row &gt;= rows || col &gt;= cols) return;&#10;                // Solo permitir inicio/fin en celdas transitables&#10;                if (e.isShiftDown() &amp;&amp; SwingUtilities.isLeftMouseButton(e)) {&#10;                    if (mazeData[row][col] == 1) {&#10;                        endPoint = new Point(col, row);&#10;                    } else {&#10;                        JOptionPane.showMessageDialog(MazePanel.this, &quot;El punto de fin debe estar en una celda transitable.&quot;, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    }&#10;                } else if (SwingUtilities.isRightMouseButton(e)) {&#10;                    if (mazeData[row][col] == 1) {&#10;                        startPoint = new Point(col, row);&#10;                    } else {&#10;                        JOptionPane.showMessageDialog(MazePanel.this, &quot;El punto de inicio debe estar en una celda transitable.&quot;, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    }&#10;                } else if (SwingUtilities.isLeftMouseButton(e)) {&#10;                    mazeData[row][col] = (mazeData[row][col] == 1) ? 0 : 1;&#10;                }&#10;                repaint();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        Graphics2D g2d = (Graphics2D) g;&#10;&#10;        // 1. Dibuja las celdas base (muros y caminos)&#10;        for (int row = 0; row &lt; rows; row++) {&#10;            for (int col = 0; col &lt; cols; col++) {&#10;                g2d.setColor(mazeData[row][col] == 0 ? Color.BLACK : Color.WHITE);&#10;                g2d.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 2. Dibuja los nodos visitados (en gris claro)&#10;        g2d.setColor(new Color(220, 220, 220)); // Un gris más claro&#10;        for (int[] node : visitedNodes) {&#10;            g2d.fillRect(node[1] * CELL_SIZE, node[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;        }&#10;&#10;        // 3. Dibuja el camino final completo (si está activo)&#10;        g2d.setColor(new Color(66, 135, 245)); // Un azul claro&#10;        for (int[] step : finalPath) {&#10;            g2d.fillRect(step[1] * CELL_SIZE, step[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;        }&#10;&#10;        // 4. Dibuja la animación paso a paso (si está activa)&#10;        if (stepByStepPathToAnimate != null &amp;&amp; !stepByStepPathToAnimate.isEmpty()) {&#10;            g2d.setColor(new Color(255, 165, 0)); // Naranja para destacar el paso a paso&#10;            // Dibuja solo los pasos hasta el índice actual&#10;            for (int i = 0; i &lt;= stepByStepCurrentIndex &amp;&amp; i &lt; stepByStepPathToAnimate.size(); i++) {&#10;                int[] step = stepByStepPathToAnimate.get(i);&#10;                g2d.fillRect(step[1] * CELL_SIZE, step[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 5. Dibuja la cuadrícula&#10;        g2d.setColor(Color.GRAY);&#10;        for (int row = 0; row &lt; rows; row++) {&#10;            for (int col = 0; col &lt; cols; col++) {&#10;                g2d.drawRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 6. Dibuja los puntos de inicio y fin encima de todo&#10;        if (startPoint != null) {&#10;            g2d.setColor(Color.GREEN);&#10;            g2d.fillRect(startPoint.x * CELL_SIZE, startPoint.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.drawString(&quot;A&quot;, startPoint.x * CELL_SIZE + 8, startPoint.y * CELL_SIZE + 18);&#10;        }&#10;        if (endPoint != null) {&#10;            g2d.setColor(Color.RED);&#10;            g2d.fillRect(endPoint.x * CELL_SIZE, endPoint.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            g2d.setColor(Color.WHITE);&#10;            g2d.drawString(&quot;B&quot;, endPoint.x * CELL_SIZE + 8, endPoint.y * CELL_SIZE + 18);&#10;        }&#10;    }&#10;&#10;    public void clearMaze() {&#10;        for (int i = 0; i &lt; rows; i++) {&#10;            for (int j = 0; j &lt; cols; j++) {&#10;                mazeData[i][j] = 1;&#10;            }&#10;        }&#10;        startPoint = null;&#10;        endPoint = null;&#10;        clearVisuals();&#10;        repaint();&#10;    }&#10;&#10;    public void clearVisuals() {&#10;        visitedNodes.clear();&#10;        finalPath.clear();&#10;        // --- NUEVO: Limpiar estado de paso a paso ---&#10;        stepByStepPathToAnimate = null;&#10;        stepByStepCurrentIndex = -1;&#10;        repaint();&#10;    }&#10;&#10;    // --- MÉTODOS PÚBLICOS PARA LOS MODOS DE DIBUJO ---&#10;&#10;    /**&#10;     * Dibuja instantáneamente solo la ruta de la solución final.&#10;     * Usado por el botón &quot;¡Resolver!&quot;.&#10;     */&#10;    public void drawSimplePath(List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Dibuja instantáneamente todos los nodos visitados y la ruta final.&#10;     * Usado por el botón &quot;Mostrar Camino Completo&quot;.&#10;     */&#10;    public void drawFullPath(List&lt;int[]&gt; visited, List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (visited != null) {&#10;            this.visitedNodes = new ArrayList&lt;&gt;(visited);&#10;        }&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Prepara el panel para la animación paso a paso, pero no la inicia.&#10;     * Guarda la ruta y reinicia el contador.&#10;     */&#10;    public void prepareForStepByStep(List&lt;int[]&gt; path) {&#10;        clearVisuals(); // Limpia cualquier dibujo anterior&#10;        if (path != null &amp;&amp; !path.isEmpty()) {&#10;            this.stepByStepPathToAnimate = new ArrayList&lt;&gt;(path);&#10;            this.stepByStepCurrentIndex = -1; // Empezamos antes del primer paso&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Avanza un paso en la animación y redibuja el panel.&#10;     * Usado por el botón &quot;Resolver Paso a Paso&quot;.&#10;     */&#10;    public void nextStep() {&#10;        if (stepByStepPathToAnimate != null &amp;&amp; stepByStepCurrentIndex &lt; stepByStepPathToAnimate.size() - 1) {&#10;            stepByStepCurrentIndex++;&#10;            repaint();&#10;        }&#10;    }&#10;&#10;    // --- Getters y Setters (sin cambios) ---&#10;    public void setMazeData(int[][] mazeData) {&#10;        if (mazeData == null || mazeData.length == 0) return;&#10;        this.rows = mazeData.length;&#10;        this.cols = mazeData[0].length;&#10;        this.mazeData = mazeData;&#10;        updatePreferredSize();&#10;        repaint();&#10;    }&#10;&#10;    private void updatePreferredSize() {&#10;        int width = cols * CELL_SIZE;&#10;        int height = rows * CELL_SIZE;&#10;        setPreferredSize(new Dimension(width, height));&#10;        revalidate(); // Fuerza el recálculo del layout&#10;        Container parent = getParent();&#10;        if (parent != null) {&#10;            parent.revalidate(); // Notifica al contenedor padre&#10;            Window window = SwingUtilities.getWindowAncestor(this);&#10;            if (window != null) {&#10;                window.pack(); // Ajusta el tamaño de la ventana&#10;            }&#10;        }&#10;    }&#10;&#10;    public int[][] getMazeData() { return mazeData; }&#10;    public Point getStartPoint() { return startPoint; }&#10;    public Point getEndPoint() { return endPoint; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vista/MazeView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vista/MazeView.java" />
              <option name="originalContent" value="// /src/main/java/vista/MazeView.java&#10;package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionListener;&#10;import java.util.List;&#10;&#10;/**&#10; * MazeView es la ventana principal (JFrame) de la aplicación de laberintos.&#10; * Ensambla el MazePanel (lienzo), el ControlPanel (botones) y la barra de menú.&#10; * Permite la interacción entre el usuario y el controlador siguiendo el patrón MVC.&#10; *&#10; * Funcionalidades principales:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Contiene y organiza los paneles de laberinto y control.&lt;/li&gt;&#10; *   &lt;li&gt;Proporciona métodos para mostrar resultados, errores y gráficas.&lt;/li&gt;&#10; *   &lt;li&gt;Permite al controlador añadir listeners a los botones y menús.&lt;/li&gt;&#10; *   &lt;li&gt;Gestiona la visualización de rutas y resultados.&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; */&#10;public class MazeView extends JFrame {&#10;&#10;    private MazePanel mazePanel;&#10;    private ControlPanel controlPanel;&#10;&#10;    // --- Atributos para los items del menú ---&#10;    private JMenuItem listResultsMenuItem;&#10;    private JMenuItem showTimesChartMenuItem;&#10;&#10;    /**&#10;     * Construye la ventana principal, inicializando y organizando todos los&#10;     * componentes de la interfaz de usuario.&#10;     */&#10;    public MazeView() {&#10;        setTitle(&quot;Solucionador de Laberintos&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout(10, 10));&#10;        setSize(500, 800);&#10;&#10;        // 1. Crear la barra de menú&#10;        createMenuBar();&#10;&#10;        // 2. Crear instancias de los paneles&#10;        mazePanel = new MazePanel(5, 5);&#10;        controlPanel = new ControlPanel();&#10;&#10;        // 3. Añadirlos a la ventana&#10;        add(mazePanel, BorderLayout.CENTER);&#10;        add(controlPanel, BorderLayout.EAST);&#10;&#10;        pack();&#10;        setLocationRelativeTo(null);&#10;        // NOTA: setVisible(true) es llamado por la clase App, no aquí.&#10;    }&#10;&#10;    /**&#10;     * Crea y configura la barra de menú de la aplicación.&#10;     * Este es un método de ayuda privado para mantener el constructor limpio.&#10;     */&#10;    private void createMenuBar() {&#10;        JMenuBar menuBar = new JMenuBar();&#10;&#10;        JMenu reportsMenu = new JMenu(&quot;Reportes&quot;);&#10;        menuBar.add(reportsMenu);&#10;&#10;        listResultsMenuItem = new JMenuItem(&quot;Listar Historial de Resultados&quot;);&#10;        showTimesChartMenuItem = new JMenuItem(&quot;Mostrar Gráfica de Tiempos&quot;);&#10;&#10;        reportsMenu.add(listResultsMenuItem);&#10;        reportsMenu.add(showTimesChartMenuItem);&#10;&#10;        setJMenuBar(menuBar);&#10;    }&#10;&#10;    // --- MÉTODOS PARA QUE EL CONTROLADOR MUESTRE VENTANAS SECUNDARIAS ---&#10;    // --- Métodos públicos para que el Controlador actualice la vista --&#10;&#10;    /**&#10;     * Crea y muestra una ventana de diálogo modal con la tabla de resultados.&#10;     * Esta acción es invocada por el Controlador.&#10;     */&#10;    public void showResultsTable() {&#10;        ResultsTableView resultsDialog = new ResultsTableView(this);&#10;        resultsDialog.setVisible(true);&#10;    }&#10;&#10;    /**&#10;     * Crea y muestra una ventana de diálogo modal para la gráfica de tiempos.&#10;     * Esta acción es invocada por el Controlador.&#10;     */&#10;    public void showTimesChart() {&#10;        TimesChartView chartDialog = new TimesChartView(this);&#10;        chartDialog.setVisible(true);&#10;    }&#10;&#10;    // --- MÉTODOS PARA QUE EL CONTROLADOR AÑADA LISTENERS ---&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el item de menú &quot;Listar Historial de Resultados&quot;.&#10;     * @param listener El ActionListener a ejecutar, típicamente proporcionado por el Controlador.&#10;     */&#10;    public void addListResultsListener(ActionListener listener) {&#10;        listResultsMenuItem.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el item de menú &quot;Mostrar Gráfica de Tiempos&quot;.&#10;     * @param listener El ActionListener a ejecutar, típicamente proporcionado por el Controlador.&#10;     */&#10;    public void addShowTimesChartListener(ActionListener listener) {&#10;        showTimesChartMenuItem.addActionListener(listener);&#10;    }&#10;&#10;    // --- MÉTODOS DE ACCESO Y UTILIDAD ---&#10;&#10;    /**&#10;     * Devuelve la instancia del panel del laberinto.&#10;     * @return El componente MazePanel.&#10;     */&#10;    public MazePanel getMazePanel() {&#10;        return mazePanel;&#10;    }&#10;&#10;    /**&#10;     * Devuelve la instancia del panel de control.&#10;     * @return El componente ControlPanel.&#10;     */&#10;    public ControlPanel getControlPanel() {&#10;        return controlPanel;&#10;    }&#10;&#10;    /**&#10;     * Muestra un mensaje de error genérico en un diálogo.&#10;     * @param message El mensaje de error a mostrar.&#10;     */&#10;    public void showError(String message) {&#10;        JOptionPane.showMessageDialog(this, message, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * Muestra los resultados de texto en el área de resultados del panel de control.&#10;     * @param results El texto con los resultados a mostrar.&#10;     */&#10;    public void setResults(String results) {&#10;        controlPanel.setResultsText(results);&#10;    }&#10;&#10;    /**&#10;     * Dibuja una ruta simple en el panel del laberinto.&#10;     * Este método delega la llamada al MazePanel.&#10;     * @param path La lista de coordenadas que componen la ruta.&#10;     */&#10;    public void drawPath(List&lt;int[]&gt; path) {&#10;        // Delega la acción al método correspondiente en MazePanel&#10;        mazePanel.drawSimplePath(path);&#10;    }&#10;&#10;    /**&#10;     * Limpia cualquier elemento visual de la solución (rutas, nodos visitados)&#10;     * en el panel del laberinto.&#10;     */&#10;    public void clearPath() {&#10;        // Delega la acción al método de limpieza visual en MazePanel&#10;        mazePanel.clearVisuals();&#10;    }&#10;}" />
              <option name="updatedContent" value="// /src/main/java/vista/MazeView.java&#10;package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionListener;&#10;import java.util.List;&#10;&#10;/**&#10; * MazeView es la ventana principal (JFrame) de la aplicación de laberintos.&#10; * Ensambla el MazePanel (lienzo), el ControlPanel (botones) y la barra de menú.&#10; * Permite la interacción entre el usuario y el controlador siguiendo el patrón MVC.&#10; *&#10; * Funcionalidades principales:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Contiene y organiza los paneles de laberinto y control.&lt;/li&gt;&#10; *   &lt;li&gt;Proporciona métodos para mostrar resultados, errores y gráficas.&lt;/li&gt;&#10; *   &lt;li&gt;Permite al controlador añadir listeners a los botones y menús.&lt;/li&gt;&#10; *   &lt;li&gt;Gestiona la visualización de rutas y resultados.&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; */&#10;public class MazeView extends JFrame {&#10;&#10;    private MazePanel mazePanel;&#10;    private ControlPanel controlPanel;&#10;&#10;    // --- Atributos para los items del menú ---&#10;    private JMenuItem listResultsMenuItem;&#10;    private JMenuItem showTimesChartMenuItem;&#10;&#10;    /**&#10;     * Construye la ventana principal, inicializando y organizando todos los&#10;     * componentes de la interfaz de usuario.&#10;     */&#10;    public MazeView() {&#10;        setTitle(&quot;Solucionador de Laberintos&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout(10, 10));&#10;        &#10;        // 1. Crear la barra de menú&#10;        createMenuBar();&#10;&#10;        // 2. Crear instancias de los paneles&#10;        mazePanel = new MazePanel(5, 5);&#10;        controlPanel = new ControlPanel();&#10;        &#10;        // Panel contenedor con scroll para el laberinto&#10;        JScrollPane scrollPane = new JScrollPane(mazePanel);&#10;        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);&#10;        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);&#10;        &#10;        // 3. Añadir los paneles a la ventana&#10;        add(scrollPane, BorderLayout.CENTER);&#10;        add(controlPanel, BorderLayout.EAST);&#10;&#10;        // Establecer un tamaño mínimo para la ventana&#10;        setMinimumSize(new Dimension(600, 400));&#10;        pack();&#10;        setLocationRelativeTo(null);&#10;        // NOTA: setVisible(true) es llamado por la clase App, no aquí.&#10;    }&#10;&#10;    /**&#10;     * Crea y configura la barra de menú de la aplicación.&#10;     * Este es un método de ayuda privado para mantener el constructor limpio.&#10;     */&#10;    private void createMenuBar() {&#10;        JMenuBar menuBar = new JMenuBar();&#10;&#10;        JMenu reportsMenu = new JMenu(&quot;Reportes&quot;);&#10;        menuBar.add(reportsMenu);&#10;&#10;        listResultsMenuItem = new JMenuItem(&quot;Listar Historial de Resultados&quot;);&#10;        showTimesChartMenuItem = new JMenuItem(&quot;Mostrar Gráfica de Tiempos&quot;);&#10;&#10;        reportsMenu.add(listResultsMenuItem);&#10;        reportsMenu.add(showTimesChartMenuItem);&#10;&#10;        setJMenuBar(menuBar);&#10;    }&#10;&#10;    // --- MÉTODOS PARA QUE EL CONTROLADOR MUESTRE VENTANAS SECUNDARIAS ---&#10;    // --- Métodos públicos para que el Controlador actualice la vista --&#10;&#10;    /**&#10;     * Crea y muestra una ventana de diálogo modal con la tabla de resultados.&#10;     * Esta acción es invocada por el Controlador.&#10;     */&#10;    public void showResultsTable() {&#10;        ResultsTableView resultsDialog = new ResultsTableView(this);&#10;        resultsDialog.setVisible(true);&#10;    }&#10;&#10;    /**&#10;     * Crea y muestra una ventana de diálogo modal para la gráfica de tiempos.&#10;     * Esta acción es invocada por el Controlador.&#10;     */&#10;    public void showTimesChart() {&#10;        TimesChartView chartDialog = new TimesChartView(this);&#10;        chartDialog.setVisible(true);&#10;    }&#10;&#10;    // --- MÉTODOS PARA QUE EL CONTROLADOR AÑADA LISTENERS ---&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el item de menú &quot;Listar Historial de Resultados&quot;.&#10;     * @param listener El ActionListener a ejecutar, típicamente proporcionado por el Controlador.&#10;     */&#10;    public void addListResultsListener(ActionListener listener) {&#10;        listResultsMenuItem.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el item de menú &quot;Mostrar Gráfica de Tiempos&quot;.&#10;     * @param listener El ActionListener a ejecutar, típicamente proporcionado por el Controlador.&#10;     */&#10;    public void addShowTimesChartListener(ActionListener listener) {&#10;        showTimesChartMenuItem.addActionListener(listener);&#10;    }&#10;&#10;    // --- MÉTODOS DE ACCESO Y UTILIDAD ---&#10;&#10;    /**&#10;     * Devuelve la instancia del panel del laberinto.&#10;     * @return El componente MazePanel.&#10;     */&#10;    public MazePanel getMazePanel() {&#10;        return mazePanel;&#10;    }&#10;&#10;    /**&#10;     * Devuelve la instancia del panel de control.&#10;     * @return El componente ControlPanel.&#10;     */&#10;    public ControlPanel getControlPanel() {&#10;        return controlPanel;&#10;    }&#10;&#10;    /**&#10;     * Muestra un mensaje de error genérico en un diálogo.&#10;     * @param message El mensaje de error a mostrar.&#10;     */&#10;    public void showError(String message) {&#10;        JOptionPane.showMessageDialog(this, message, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * Muestra los resultados de texto en el área de resultados del panel de control.&#10;     * @param results El texto con los resultados a mostrar.&#10;     */&#10;    public void setResults(String results) {&#10;        controlPanel.setResultsText(results);&#10;    }&#10;&#10;    /**&#10;     * Dibuja una ruta simple en el panel del laberinto.&#10;     * Este método delega la llamada al MazePanel.&#10;     * @param path La lista de coordenadas que componen la ruta.&#10;     */&#10;    public void drawPath(List&lt;int[]&gt; path) {&#10;        // Delega la acción al método correspondiente en MazePanel&#10;        mazePanel.drawSimplePath(path);&#10;    }&#10;&#10;    /**&#10;     * Limpia cualquier elemento visual de la solución (rutas, nodos visitados)&#10;     * en el panel del laberinto.&#10;     */&#10;    public void clearPath() {&#10;        // Delega la acción al método de limpieza visual en MazePanel&#10;        mazePanel.clearVisuals();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vista/ResultsTableView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vista/ResultsTableView.java" />
              <option name="originalContent" value="// /src/main/java/vista/ResultsTableView.java&#10;package vista;&#10;&#10;import javax.swing.*;&#10;import javax.swing.table.DefaultTableModel;&#10;import java.awt.*;&#10;import java.io.BufferedReader;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Una ventana de diálogo (JDialog) que muestra los resultados de los laberintos&#10; * leídos desde un archivo CSV en una tabla (JTable).&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; */&#10;public class ResultsTableView extends JDialog {&#10;&#10;    /**&#10;     * Construye la ventana de diálogo, lee el archivo CSV y puebla la tabla.&#10;     * Si el archivo no se encuentra, muestra un diálogo de error.&#10;     *&#10;     * @param owner La ventana principal (JFrame) que es dueña de este diálogo.&#10;     *              Esto asegura que el diálogo se comporte de manera modal.&#10;     */&#10;    public ResultsTableView(Frame owner) {&#10;        super(owner, &quot;Historial de Resultados&quot;, true); // true para hacerlo modal&#10;        setSize(800, 400);&#10;        setLocationRelativeTo(owner);&#10;&#10;        DefaultTableModel tableModel = new DefaultTableModel();&#10;        JTable table = new JTable(tableModel);&#10;        table.setFillsViewportHeight(true); // La tabla ocupa todo el alto&#10;&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;resultados_laberinto.csv&quot;))) {&#10;            // Leer cabeceras&#10;            String headerLine = br.readLine();&#10;            if (headerLine != null) {&#10;                String[] headers = headerLine.split(&quot;,&quot;);&#10;                for (String header : headers) {&#10;                    tableModel.addColumn(header);&#10;                }&#10;            }&#10;&#10;            // Leer filas de datos&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] data = line.split(&quot;,&quot;);&#10;                tableModel.addRow(data);&#10;            }&#10;        } catch (IOException e) {&#10;            JOptionPane.showMessageDialog(this,&#10;                    &quot;No se pudo leer el archivo 'resultados_laberinto.csv'.\nError: &quot; + e.getMessage(),&#10;                    &quot;Error de Archivo&quot;,&#10;                    JOptionPane.ERROR_MESSAGE);&#10;        }&#10;&#10;        add(new JScrollPane(table), BorderLayout.CENTER);&#10;    }&#10;}" />
              <option name="updatedContent" value="// /src/main/java/vista/ResultsTableView.java&#13;&#10;package vista;&#13;&#10;&#13;&#10;import javax.swing.*;&#13;&#10;import javax.swing.table.DefaultTableModel;&#13;&#10;import java.awt.*;&#13;&#10;import java.io.BufferedReader;&#13;&#10;import java.io.FileReader;&#13;&#10;import java.io.IOException;&#13;&#10;&#13;&#10;/**&#13;&#10; * Ventana de diálogo que muestra una tabla con el historial de resultados&#13;&#10; * de los algoritmos ejecutados. Lee los datos desde el archivo CSV y los&#13;&#10; * presenta en un formato tabular fácil de leer.&#13;&#10; *&#13;&#10; * Características:&#13;&#10; * &lt;ul&gt;&#13;&#10; *   &lt;li&gt;Muestra timestamp, algoritmo, éxito y tiempo de ejecución&lt;/li&gt;&#13;&#10; *   &lt;li&gt;Permite ordenar por cualquier columna&lt;/li&gt;&#13;&#10; *   &lt;li&gt;Implementa scroll para manejar muchos registros&lt;/li&gt;&#13;&#10; *   &lt;li&gt;Actualiza la vista al abrirse&lt;/li&gt;&#13;&#10; * &lt;/ul&gt;&#13;&#10; *&#13;&#10; * @author Israel Orellana&#13;&#10; * @version 1.0&#13;&#10; */&#13;&#10;public class ResultsTableView extends JDialog {&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Construye la ventana de diálogo, lee el archivo CSV y puebla la tabla.&#13;&#10;     * Si el archivo no se encuentra, muestra un diálogo de error.&#13;&#10;     *&#13;&#10;     * @param owner La ventana principal (JFrame) que es dueña de este diálogo.&#13;&#10;     *              Esto asegura que el diálogo se comporte de manera modal.&#13;&#10;     */&#13;&#10;    public ResultsTableView(Frame owner) {&#13;&#10;        super(owner, &quot;Historial de Resultados&quot;, true); // true para hacerlo modal&#13;&#10;        setSize(800, 400);&#13;&#10;        setLocationRelativeTo(owner);&#13;&#10;&#13;&#10;        DefaultTableModel tableModel = new DefaultTableModel();&#13;&#10;        JTable table = new JTable(tableModel);&#13;&#10;        table.setFillsViewportHeight(true); // La tabla ocupa todo el alto&#13;&#10;&#13;&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;resultados_laberinto.csv&quot;))) {&#13;&#10;            // Leer cabeceras&#13;&#10;            String headerLine = br.readLine();&#13;&#10;            if (headerLine != null) {&#13;&#10;                String[] headers = headerLine.split(&quot;,&quot;);&#13;&#10;                for (String header : headers) {&#13;&#10;                    tableModel.addColumn(header);&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            // Leer filas de datos&#13;&#10;            String line;&#13;&#10;            while ((line = br.readLine()) != null) {&#13;&#10;                String[] data = line.split(&quot;,&quot;);&#13;&#10;                tableModel.addRow(data);&#13;&#10;            }&#13;&#10;        } catch (IOException e) {&#13;&#10;            JOptionPane.showMessageDialog(this,&#13;&#10;                    &quot;No se pudo leer el archivo 'resultados_laberinto.csv'.\nError: &quot; + e.getMessage(),&#13;&#10;                    &quot;Error de Archivo&quot;,&#13;&#10;                    JOptionPane.ERROR_MESSAGE);&#13;&#10;        }&#13;&#10;&#13;&#10;        add(new JScrollPane(table), BorderLayout.CENTER);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vista/TimesChartView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vista/TimesChartView.java" />
              <option name="originalContent" value="// /src/main/java/vista/TimesChartView.java&#10;package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import org.jfree.chart.ChartFactory;&#10;import org.jfree.chart.ChartPanel;&#10;import org.jfree.chart.JFreeChart;&#10;import org.jfree.chart.plot.PlotOrientation;&#10;import org.jfree.data.category.DefaultCategoryDataset;&#10;import java.io.BufferedReader;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Una ventana de diálogo (JDialog) para mostrar la gráfica de comparación de tiempos.&#10; * &lt;p&gt;&#10; * Actualmente, esta clase actúa como un &lt;b&gt;placeholder&lt;/b&gt;, mostrando un mensaje&#10; * de texto. En una futura implementación, podría integrarse con una librería&#10; * de gráficos como JFreeChart para visualizar los datos de rendimiento.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; */&#10;public class TimesChartView extends JDialog {&#10;&#10;    /**&#10;     * Construye la ventana de diálogo para la gráfica de tiempos.&#10;     *&#10;     * @param owner La ventana principal (JFrame) que es dueña de este diálogo,&#10;     *              asegurando que el diálogo se comporte de manera modal.&#10;     */&#10;    public TimesChartView(Frame owner) {&#10;        super(owner, &quot;Gráfica de Tiempos de Ejecución&quot;, true);&#10;        setSize(800, 600);&#10;        setLocationRelativeTo(owner);&#10;&#10;        DefaultCategoryDataset dataset = new DefaultCategoryDataset();&#10;        boolean tieneDatos = false;&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;resultados_laberinto.csv&quot;))) {&#10;            String header = br.readLine(); // Leer encabezado&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length &gt;= 5) {&#10;                    String timestamp = parts[0].trim();&#10;                    String algoritmo = parts[1].trim();&#10;                    double tiempo = Double.parseDouble(parts[4].trim());&#10;                    dataset.addValue(tiempo, algoritmo, timestamp);&#10;                    tieneDatos = true;&#10;                }&#10;            }&#10;        } catch (IOException | NumberFormatException ex) {&#10;            JLabel errorLabel = new JLabel(&quot;Error al leer el archivo CSV o formato incorrecto.&quot;, SwingConstants.CENTER);&#10;            errorLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;            add(errorLabel, BorderLayout.CENTER);&#10;            return;&#10;        }&#10;        if (!tieneDatos) {&#10;            JLabel vacioLabel = new JLabel(&quot;No hay datos de tiempos para mostrar.&quot;, SwingConstants.CENTER);&#10;            vacioLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;            add(vacioLabel, BorderLayout.CENTER);&#10;            return;&#10;        }&#10;        JFreeChart lineChart = ChartFactory.createLineChart(&#10;                &quot;Comparación de Tiempos de Algoritmos&quot;,&#10;                &quot;Timestamp&quot;,&#10;                &quot;Tiempo (ms)&quot;,&#10;                dataset,&#10;                PlotOrientation.VERTICAL,&#10;                true, true, false&#10;        );&#10;        // Personalización de colores y diseño&#10;        lineChart.setBackgroundPaint(Color.WHITE);&#10;        lineChart.getPlot().setBackgroundPaint(new Color(240, 240, 255));&#10;&#10;        ChartPanel chartPanel = new ChartPanel(lineChart);&#10;        setLayout(new BorderLayout());&#10;        add(chartPanel, BorderLayout.CENTER);&#10;    }&#10;}" />
              <option name="updatedContent" value="// /src/main/java/vista/TimesChartView.java&#10;package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import org.jfree.chart.ChartFactory;&#10;import org.jfree.chart.ChartPanel;&#10;import org.jfree.chart.JFreeChart;&#10;import org.jfree.chart.plot.PlotOrientation;&#10;import org.jfree.data.category.DefaultCategoryDataset;&#10;import java.io.BufferedReader;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Ventana de diálogo que muestra una gráfica de líneas comparando los tiempos&#10; * de ejecución de los diferentes algoritmos de búsqueda en el laberinto.&#10; *&#10; * Características:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Lee datos del archivo CSV de resultados&lt;/li&gt;&#10; *   &lt;li&gt;Genera gráfica de líneas usando JFreeChart&lt;/li&gt;&#10; *   &lt;li&gt;Muestra diferentes algoritmos con colores distintos&lt;/li&gt;&#10; *   &lt;li&gt;Permite comparar rendimiento visual y numéricamente&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * La gráfica muestra:&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;Eje X: Timestamp de ejecución&lt;/li&gt;&#10; *   &lt;li&gt;Eje Y: Tiempo de ejecución en milisegundos&lt;/li&gt;&#10; *   &lt;li&gt;Leyenda: Identificación de algoritmos&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; */&#10;public class TimesChartView extends JDialog {&#10;&#10;    /**&#10;     * Construye la ventana de diálogo para la gráfica de tiempos.&#10;     *&#10;     * @param owner La ventana principal (JFrame) que es dueña de este diálogo,&#10;     *              asegurando que el diálogo se comporte de manera modal.&#10;     */&#10;    public TimesChartView(Frame owner) {&#10;        super(owner, &quot;Gráfica de Tiempos de Ejecución&quot;, true);&#10;        setSize(800, 600);&#10;        setLocationRelativeTo(owner);&#10;&#10;        DefaultCategoryDataset dataset = new DefaultCategoryDataset();&#10;        boolean tieneDatos = false;&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;resultados_laberinto.csv&quot;))) {&#10;            String header = br.readLine(); // Leer encabezado&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length &gt;= 5) {&#10;                    String timestamp = parts[0].trim();&#10;                    String algoritmo = parts[1].trim();&#10;                    double tiempo = Double.parseDouble(parts[4].trim());&#10;                    dataset.addValue(tiempo, algoritmo, timestamp);&#10;                    tieneDatos = true;&#10;                }&#10;            }&#10;        } catch (IOException | NumberFormatException ex) {&#10;            JLabel errorLabel = new JLabel(&quot;Error al leer el archivo CSV o formato incorrecto.&quot;, SwingConstants.CENTER);&#10;            errorLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;            add(errorLabel, BorderLayout.CENTER);&#10;            return;&#10;        }&#10;        if (!tieneDatos) {&#10;            JLabel vacioLabel = new JLabel(&quot;No hay datos de tiempos para mostrar.&quot;, SwingConstants.CENTER);&#10;            vacioLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;            add(vacioLabel, BorderLayout.CENTER);&#10;            return;&#10;        }&#10;        JFreeChart lineChart = ChartFactory.createLineChart(&#10;                &quot;Comparación de Tiempos de Algoritmos&quot;,&#10;                &quot;Timestamp&quot;,&#10;                &quot;Tiempo (ms)&quot;,&#10;                dataset,&#10;                PlotOrientation.VERTICAL,&#10;                true, true, false&#10;        );&#10;        // Personalización de colores y diseño&#10;        lineChart.setBackgroundPaint(Color.WHITE);&#10;        lineChart.getPlot().setBackgroundPaint(new Color(240, 240, 255));&#10;&#10;        ChartPanel chartPanel = new ChartPanel(lineChart);&#10;        setLayout(new BorderLayout());&#10;        add(chartPanel, BorderLayout.CENTER);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>