<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="updatedContent" value="&lt;!-- ...existing code... --&gt;&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;org.jfree&lt;/groupId&gt;&#10;    &lt;artifactId&gt;jfreechart&lt;/artifactId&gt;&#10;    &lt;version&gt;1.5.3&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;&lt;!-- ...existing code... --&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/controlador/Controller.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/controlador/Controller.java" />
              <option name="originalContent" value="// /src/main/java/controlador/Controller.java&#10;package controlador;&#10;&#10;import modelo.*;&#10;import vista.MazeView;&#10;import util.CSVLogger; // Crearemos esta clase de utilidad&#10;&#10;import java.awt.Point;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * El controlador principal de la aplicación. Conecta la Vista (MazeView)&#10; * con el Modelo (los algoritmos de resolución de laberintos).&#10; *&#10; * @author Einar Kaalhus&#10; * @version 1.0&#10; */&#10;public class Controller {&#10;    private final MazeView view;&#10;    private final CSVLogger csvLogger;&#10;&#10;    public Controller(MazeView view) {&#10;        this.view = view;&#10;        this.csvLogger = new CSVLogger(&quot;resultados_laberinto.csv&quot;);&#10;        initController();&#10;    }&#10;&#10;    /**&#10;     * Inicializa el controlador asignando listeners a los componentes de la vista.&#10;     */&#10;    private void initController() {&#10;        // La vista ya no maneja la lógica, solo notifica al controlador.&#10;        view.getControlPanel().addGenerateListener(e -&gt; generateNewMaze());&#10;        view.getControlPanel().addSolveListener(e -&gt; solveMaze());&#10;&#10;        view.addListResultsListener(e -&gt; view.showResultsTable());&#10;        view.addShowTimesChartListener(e -&gt; view.showTimesChart());&#10;    }&#10;&#10;    /**&#10;     * Orquesta la limpieza y generación de un nuevo laberinto en la vista.&#10;     */&#10;    private void generateNewMaze() {&#10;        int rows = view.getControlPanel().getRows();&#10;        int cols = view.getControlPanel().getCols();&#10;        view.getMazePanel().setMazeData(new int[rows][cols]); // Crea una nueva matriz&#10;        view.getMazePanel().clearMaze(); // Limpia estado (puntos, ruta)&#10;        view.pack(); // Reajusta el tamaño de la ventana&#10;    }&#10;&#10;    /**&#10;     * Orquesta todo el proceso de resolución del laberinto.&#10;     */&#10;    private void solveMaze() {&#10;        // Limpiar visualización antes de resolver con otro método&#10;        view.getMazePanel().clearVisuals();&#10;        // 1. Recoger datos de la Vista&#10;        int[][] mazeData = view.getMazePanel().getMazeData();&#10;        Point startPoint = view.getMazePanel().getStartPoint();&#10;        Point endPoint = view.getMazePanel().getEndPoint();&#10;        String algorithm = view.getControlPanel().getSelectedAlgorithm();&#10;&#10;        // 2. Validar datos de entrada&#10;        if (startPoint == null || endPoint == null) {&#10;            view.showError(&quot;Por favor, defina un punto de inicio (clic derecho) y un punto de fin (Shift + clic izquierdo).&quot;);&#10;            return;&#10;        }&#10;&#10;        if (mazeData[startPoint.y][startPoint.x] == 0 || mazeData[endPoint.y][endPoint.x] == 0) {&#10;            view.showError(&quot;El punto de inicio o fin está en un muro.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Validación especial para recursivo 2 direcciones&#10;        if (algorithm != null &amp;&amp; algorithm.contains(&quot;2 dir&quot;)) {&#10;            if (endPoint.y &lt; startPoint.y || endPoint.x &lt; startPoint.x) {&#10;                view.showError(&quot;El método recursivo de 2 direcciones solo funciona si el destino está a la derecha y abajo del inicio.&quot;);&#10;                return;&#10;            }&#10;        }&#10;&#10;        // 3. Preparar datos, ejecutar el algoritmo y medir el tiempo&#10;        long startTime = System.nanoTime();&#10;        List&lt;int[]&gt; path = findPath(mazeData, startPoint, endPoint, algorithm);&#10;        long endTime = System.nanoTime();&#10;        double durationMs = (endTime - startTime) / 1_000_000.0;&#10;&#10;        // 4. Formatear y mostrar resultados en la Vista&#10;        boolean success = !path.isEmpty();&#10;        String resultText;&#10;        if (success) {&#10;            resultText = String.format(&quot;Algoritmo: %s\nRuta encontrada.\nPasos: %d\nTiempo: %.4f ms&quot;,&#10;                    algorithm, path.size(), durationMs);&#10;            view.drawPath(path);&#10;        } else {&#10;            resultText = String.format(&quot;Algoritmo: %s\nNo se encontró ruta.\nTiempo: %.4f ms&quot;,&#10;                    algorithm, durationMs);&#10;            view.clearPath();&#10;        }&#10;        view.setResults(resultText);&#10;&#10;        // 5. Guardar resultados en CSV&#10;        csvLogger.logResult(algorithm, success, path.size(), durationMs);&#10;    }&#10;&#10;    /**&#10;     * Selecciona y ejecuta el algoritmo de resolución apropiado.&#10;     *&#10;     * @return La lista de celdas del camino encontrado.&#10;     */&#10;    private List&lt;int[]&gt; findPath(int[][] mazeData, Point startPoint, Point endPoint, String algorithm) {&#10;        // Para BFS y DFS, necesitamos convertir la matriz a nuestro modelo de objetos&#10;        Laberinto laberinto = new Laberinto(mazeData.length, mazeData[0].length);&#10;        for (int i = 0; i &lt; mazeData.length; i++) {&#10;            for (int j = 0; j &lt; mazeData[0].length; j++) {&#10;                if (mazeData[i][j] == 0) {&#10;                    laberinto.setMuro(i, j);&#10;                }&#10;            }&#10;        }&#10;        Celda inicio = laberinto.getCelda(startPoint.y, startPoint.x);&#10;        Celda fin = laberinto.getCelda(endPoint.y, endPoint.x);&#10;&#10;        switch (algorithm) {&#10;            case &quot;BFS&quot;:&#10;                SolverBFS bfs = new SolverBFS();&#10;                List&lt;Celda&gt; bfsPath = bfs.buscarRuta(laberinto, inicio, fin);&#10;                return convertCeldaPathToIntArrayPath(bfsPath);&#10;&#10;            case &quot;DFS&quot;:&#10;                SolverDFS dfs = new SolverDFS();&#10;                List&lt;Celda&gt; dfsPath = dfs.buscarRuta(laberinto, inicio, fin);&#10;                return convertCeldaPathToIntArrayPath(dfsPath);&#10;&#10;            // En método findPath(), actualiza así las llamadas a SolverRecursivo:&#10;            case &quot;Recursivo (2 dir)&quot;:&#10;                SolverRecursivo rec2 = new SolverRecursivo();&#10;                List&lt;int[]&gt; res2 = rec2.resolver2Direcciones(mazeData, startPoint.y, startPoint.x, endPoint.y, endPoint.x);&#10;                return res2 != null ? res2 : new ArrayList&lt;&gt;();&#10;&#10;            case &quot;Recursivo (4 dir)&quot;:&#10;                SolverRecursivo rec4 = new SolverRecursivo();&#10;                List&lt;int[]&gt; res4 = rec4.resolver4Direcciones(mazeData, startPoint.y, startPoint.x, endPoint.y, endPoint.x);&#10;                return res4 != null ? res4 : new ArrayList&lt;&gt;();&#10;&#10;            case &quot;Backtracking&quot;:&#10;                SolverRecursivo backtrack = new SolverRecursivo();&#10;                List&lt;int[]&gt; bt = backtrack.resolverBacktracking(mazeData, startPoint.y, startPoint.x, endPoint.y, endPoint.x);&#10;                return bt != null ? bt : new ArrayList&lt;&gt;();&#10;&#10;&#10;            default:&#10;                return new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Convierte una lista de objetos Celda a una lista de arrays de enteros [fila, columna].&#10;     */&#10;    private List&lt;int[]&gt; convertCeldaPathToIntArrayPath(List&lt;Celda&gt; celdaPath) {&#10;        if (celdaPath == null) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;        return celdaPath.stream()&#10;                .map(c -&gt; new int[]{c.getFila(), c.getColumna()})&#10;                .collect(Collectors.toList());&#10;    }&#10;}" />
              <option name="updatedContent" value="// /src/main/java/controlador/Controller.java&#10;package controlador;&#10;&#10;import modelo.*;&#10;import vista.MazeView;&#10;import util.CSVLogger; // Crearemos esta clase de utilidad&#10;&#10;import java.awt.Point;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * El controlador principal de la aplicación. Conecta la Vista (MazeView)&#10; * con el Modelo (los algoritmos de resolución de laberintos).&#10; *&#10; * @author Einar Kaalhus&#10; * @version 1.0&#10; */&#10;public class Controller {&#10;    private final MazeView view;&#10;    private final CSVLogger csvLogger;&#10;&#10;    public Controller(MazeView view) {&#10;        this.view = view;&#10;        this.csvLogger = new CSVLogger(&quot;resultados_laberinto.csv&quot;);&#10;        initController();&#10;    }&#10;&#10;    /**&#10;     * Inicializa el controlador asignando listeners a los componentes de la vista.&#10;     */&#10;    private void initController() {&#10;        // La vista ya no maneja la lógica, solo notifica al controlador.&#10;        view.getControlPanel().addGenerateListener(e -&gt; generateNewMaze());&#10;        view.getControlPanel().addSolveListener(e -&gt; solveMaze());&#10;        view.getControlPanel().addClearAllListener(e -&gt; clearAll());&#10;&#10;        view.addListResultsListener(e -&gt; view.showResultsTable());&#10;        view.addShowTimesChartListener(e -&gt; view.showTimesChart());&#10;    }&#10;&#10;    /**&#10;     * Orquesta la limpieza y generación de un nuevo laberinto en la vista.&#10;     */&#10;    private void generateNewMaze() {&#10;        int rows = view.getControlPanel().getRows();&#10;        int cols = view.getControlPanel().getCols();&#10;        view.getMazePanel().setMazeData(new int[rows][cols]); // Crea una nueva matriz&#10;        view.getMazePanel().clearMaze(); // Limpia estado (puntos, ruta)&#10;        view.pack(); // Reajusta el tamaño de la ventana&#10;    }&#10;&#10;    /**&#10;     * Orquesta todo el proceso de resolución del laberinto.&#10;     */&#10;    private void solveMaze() {&#10;        // Limpiar visualización antes de resolver con otro método&#10;        view.getMazePanel().clearVisuals();&#10;        // 1. Recoger datos de la Vista&#10;        int[][] mazeData = view.getMazePanel().getMazeData();&#10;        Point startPoint = view.getMazePanel().getStartPoint();&#10;        Point endPoint = view.getMazePanel().getEndPoint();&#10;        String algorithm = view.getControlPanel().getSelectedAlgorithm();&#10;&#10;        // 2. Validar datos de entrada&#10;        if (startPoint == null || endPoint == null) {&#10;            view.showError(&quot;Por favor, defina un punto de inicio (clic derecho) y un punto de fin (Shift + clic izquierdo).&quot;);&#10;            return;&#10;        }&#10;&#10;        if (mazeData[startPoint.y][startPoint.x] == 0 || mazeData[endPoint.y][endPoint.x] == 0) {&#10;            view.showError(&quot;El punto de inicio o fin está en un muro.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Validación especial para recursivo 2 direcciones&#10;        if (algorithm != null &amp;&amp; algorithm.contains(&quot;2 dir&quot;)) {&#10;            if (endPoint.y &lt; startPoint.y || endPoint.x &lt; startPoint.x) {&#10;                view.showError(&quot;El método recursivo de 2 direcciones solo funciona si el destino está a la derecha y abajo del inicio.&quot;);&#10;                return;&#10;            }&#10;        }&#10;&#10;        // 3. Preparar datos, ejecutar el algoritmo y medir el tiempo&#10;        long startTime = System.nanoTime();&#10;        List&lt;int[]&gt; path = findPath(mazeData, startPoint, endPoint, algorithm);&#10;        long endTime = System.nanoTime();&#10;        double durationMs = (endTime - startTime) / 1_000_000.0;&#10;&#10;        // 4. Formatear y mostrar resultados en la Vista&#10;        boolean success = !path.isEmpty();&#10;        String resultText;&#10;        if (success) {&#10;            resultText = String.format(&quot;Algoritmo: %s\nRuta encontrada.\nPasos: %d\nTiempo: %.4f ms&quot;,&#10;                    algorithm, path.size(), durationMs);&#10;            view.drawPath(path);&#10;        } else {&#10;            resultText = String.format(&quot;Algoritmo: %s\nNo se encontró ruta.\nTiempo: %.4f ms&quot;,&#10;                    algorithm, durationMs);&#10;            view.clearPath();&#10;        }&#10;        view.setResults(resultText);&#10;&#10;        // 5. Guardar resultados en CSV&#10;        csvLogger.logResult(algorithm, success, path.size(), durationMs);&#10;    }&#10;&#10;    /**&#10;     * Selecciona y ejecuta el algoritmo de resolución apropiado.&#10;     *&#10;     * @return La lista de celdas del camino encontrado.&#10;     */&#10;    private List&lt;int[]&gt; findPath(int[][] mazeData, Point startPoint, Point endPoint, String algorithm) {&#10;        // Para BFS y DFS, necesitamos convertir la matriz a nuestro modelo de objetos&#10;        Laberinto laberinto = new Laberinto(mazeData.length, mazeData[0].length);&#10;        for (int i = 0; i &lt; mazeData.length; i++) {&#10;            for (int j = 0; j &lt; mazeData[0].length; j++) {&#10;                if (mazeData[i][j] == 0) {&#10;                    laberinto.setMuro(i, j);&#10;                }&#10;            }&#10;        }&#10;        Celda inicio = laberinto.getCelda(startPoint.y, startPoint.x);&#10;        Celda fin = laberinto.getCelda(endPoint.y, endPoint.x);&#10;&#10;        switch (algorithm) {&#10;            case &quot;BFS&quot;:&#10;                SolverBFS bfs = new SolverBFS();&#10;                List&lt;Celda&gt; bfsPath = bfs.buscarRuta(laberinto, inicio, fin);&#10;                return convertCeldaPathToIntArrayPath(bfsPath);&#10;&#10;            case &quot;DFS&quot;:&#10;                SolverDFS dfs = new SolverDFS();&#10;                List&lt;Celda&gt; dfsPath = dfs.buscarRuta(laberinto, inicio, fin);&#10;                return convertCeldaPathToIntArrayPath(dfsPath);&#10;&#10;            // En método findPath(), actualiza así las llamadas a SolverRecursivo:&#10;            case &quot;Recursivo (2 dir)&quot;:&#10;                SolverRecursivo rec2 = new SolverRecursivo();&#10;                List&lt;int[]&gt; res2 = rec2.resolver2Direcciones(mazeData, startPoint.y, startPoint.x, endPoint.y, endPoint.x);&#10;                return res2 != null ? res2 : new ArrayList&lt;&gt;();&#10;&#10;            case &quot;Recursivo (4 dir)&quot;:&#10;                SolverRecursivo rec4 = new SolverRecursivo();&#10;                List&lt;int[]&gt; res4 = rec4.resolver4Direcciones(mazeData, startPoint.y, startPoint.x, endPoint.y, endPoint.x);&#10;                return res4 != null ? res4 : new ArrayList&lt;&gt;();&#10;&#10;            case &quot;Backtracking&quot;:&#10;                SolverRecursivo backtrack = new SolverRecursivo();&#10;                List&lt;int[]&gt; bt = backtrack.resolverBacktracking(mazeData, startPoint.y, startPoint.x, endPoint.y, endPoint.x);&#10;                return bt != null ? bt : new ArrayList&lt;&gt;();&#10;&#10;&#10;            default:&#10;                return new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Convierte una lista de objetos Celda a una lista de arrays de enteros [fila, columna].&#10;     */&#10;    private List&lt;int[]&gt; convertCeldaPathToIntArrayPath(List&lt;Celda&gt; celdaPath) {&#10;        if (celdaPath == null) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;        return celdaPath.stream()&#10;                .map(c -&gt; new int[]{c.getFila(), c.getColumna()})&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    private void clearAll() {&#10;        view.getMazePanel().clearMaze();&#10;        view.getControlPanel().setResultsText(&quot;&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/modelo/SolverRecursivo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/modelo/SolverRecursivo.java" />
              <option name="originalContent" value="package modelo;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.ArrayList;&#10;import java.util.HashMap;&#10;&#10;public class SolverRecursivo {&#10;    private Map&lt;String, Boolean&gt; memo = new HashMap&lt;&gt;();&#10;&#10;    // Movimientos para 2 direcciones: derecha y abajo&#10;    private static final int[] dx2 = {0, 1};&#10;    private static final int[] dy2 = {1, 0};&#10;&#10;    // Movimientos para 4 direcciones&#10;    private static final int[] dx4 = {0, 0, 1, -1};&#10;    private static final int[] dy4 = {1, -1, 0, 0};&#10;&#10;    private boolean[][] visitado;&#10;    private List&lt;int[]&gt; rutaActual;&#10;    private List&lt;int[]&gt; mejorRuta;&#10;&#10;    private void inicializar(int[][] laberinto) {&#10;        visitado = new boolean[laberinto.length][laberinto[0].length];&#10;        rutaActual = new ArrayList&lt;&gt;();&#10;        mejorRuta = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    public List&lt;int[]&gt; resolver2Direcciones(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        // Validación especial: solo puede ir a la derecha y abajo&#10;        if (finFila &lt; fila || finCol &lt; col) return new ArrayList&lt;&gt;();&#10;        backtrack2(laberinto, fila, col, finFila, finCol);&#10;        return mejorRuta;&#10;    }&#10;&#10;    private void backtrack2(int[][] lab, int x, int y, int fx, int fy) {&#10;        if (!esValido(lab, x, y) || visitado[x][y]) return;&#10;5        visitado[x][y] = true;&#10;        rutaActual.add(new int[]{x, y});&#10;        if (x == fx &amp;&amp; y == fy) {&#10;            if (mejorRuta.isEmpty() || rutaActual.size() &lt; mejorRuta.size()) {&#10;                mejorRuta = new ArrayList&lt;&gt;(rutaActual);&#10;            }&#10;        } else {&#10;            for (int i = 0; i &lt; 2; i++) {&#10;                backtrack2(lab, x + dx2[i], y + dy2[i], fx, fy);&#10;            }&#10;        }&#10;        rutaActual.remove(rutaActual.size() - 1);&#10;        visitado[x][y] = false;&#10;    }&#10;&#10;    public List&lt;int[]&gt; resolver4Direcciones(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        backtrack4(laberinto, fila, col, finFila, finCol);&#10;        return mejorRuta;&#10;    }&#10;&#10;    private void backtrack4(int[][] lab, int x, int y, int fx, int fy) {&#10;        if (!esValido(lab, x, y) || visitado[x][y]) return;&#10;        visitado[x][y] = true;&#10;        rutaActual.add(new int[]{x, y});&#10;        if (x == fx &amp;&amp; y == fy) {&#10;            if (mejorRuta.isEmpty() || rutaActual.size() &lt; mejorRuta.size()) {&#10;                mejorRuta = new ArrayList&lt;&gt;(rutaActual);&#10;            }&#10;        } else {&#10;            for (int i = 0; i &lt; 4; i++) {&#10;                backtrack4(lab, x + dx4[i], y + dy4[i], fx, fy);&#10;            }&#10;        }&#10;        rutaActual.remove(rutaActual.size() - 1);&#10;        visitado[x][y] = false;&#10;    }&#10;&#10;    public List&lt;int[]&gt; resolverBacktracking(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        backtrackCompleto(laberinto, fila, col, finFila, finCol, new ArrayList&lt;&gt;());&#10;        return mejorRuta;&#10;    }&#10;&#10;    private void backtrackCompleto(int[][] lab, int x, int y, int fx, int fy, List&lt;int[]&gt; camino) {&#10;        if (!esValido(lab, x, y) || visitado[x][y]) return;&#10;        visitado[x][y] = true;&#10;        camino.add(new int[]{x, y});&#10;        if (x == fx &amp;&amp; y == fy) {&#10;            if (mejorRuta.isEmpty() || camino.size() &lt; mejorRuta.size()) {&#10;                mejorRuta = new ArrayList&lt;&gt;(camino);&#10;            }&#10;        } else {&#10;            for (int i = 0; i &lt; 4; i++) {&#10;                backtrackCompleto(lab, x + dx4[i], y + dy4[i], fx, fy, camino);&#10;            }&#10;        }&#10;        camino.remove(camino.size() - 1);&#10;        visitado[x][y] = false;&#10;    }&#10;&#10;    public List&lt;int[]&gt; resolverBacktrackingConMemo(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        memo.clear();&#10;        backtrackConMemo(laberinto, fila, col, finFila, finCol, new ArrayList&lt;&gt;());&#10;        return mejorRuta;&#10;    }&#10;&#10;    private boolean backtrackConMemo(int[][] lab, int x, int y, int fx, int fy, List&lt;int[]&gt; camino) {&#10;        String key = x + &quot;,&quot; + y;&#10;        if (memo.containsKey(key)) return memo.get(key);&#10;        if (!esValido(lab, x, y) || visitado[x][y]) return false;&#10;&#10;        visitado[x][y] = true;&#10;        camino.add(new int[]{x, y});&#10;&#10;        boolean found = false;&#10;        if (x == fx &amp;&amp; y == fy) {&#10;            mejorRuta = new ArrayList&lt;&gt;(camino);&#10;            found = true;&#10;        } else {&#10;            for (int i = 0; i &lt; 4; i++) {&#10;                if (backtrackConMemo(lab, x + dx4[i], y + dy4[i], fx, fy, camino)) {&#10;                    found = true;&#10;                }&#10;            }&#10;        }&#10;&#10;        visitado[x][y] = false;&#10;        camino.remove(camino.size() - 1);&#10;        memo.put(key, found);&#10;        return found;&#10;    }&#10;&#10;    private boolean esValido(int[][] lab, int x, int y) {&#10;        return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; lab.length &amp;&amp; y &lt; lab[0].length &amp;&amp; lab[x][y] == 1;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package modelo;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.ArrayList;&#10;import java.util.HashMap;&#10;&#10;public class SolverRecursivo {&#10;    private Map&lt;String, Boolean&gt; memo = new HashMap&lt;&gt;();&#10;&#10;    // Movimientos para 2 direcciones: derecha y abajo&#10;    private static final int[] dx2 = {0, 1};&#10;    private static final int[] dy2 = {1, 0};&#10;&#10;    // Movimientos para 4 direcciones&#10;    private static final int[] dx4 = {0, 0, 1, -1};&#10;    private static final int[] dy4 = {1, -1, 0, 0};&#10;&#10;    private boolean[][] visitado;&#10;    private List&lt;int[]&gt; rutaActual;&#10;    private List&lt;int[]&gt; mejorRuta;&#10;&#10;    private void inicializar(int[][] laberinto) {&#10;        visitado = new boolean[laberinto.length][laberinto[0].length];&#10;        rutaActual = new ArrayList&lt;&gt;();&#10;        mejorRuta = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    public List&lt;int[]&gt; resolver2Direcciones(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        // Validación especial: solo puede ir a la derecha y abajo&#10;        if (finFila &lt; fila || finCol &lt; col) return new ArrayList&lt;&gt;();&#10;        backtrack2(laberinto, fila, col, finFila, finCol);&#10;        return mejorRuta;&#10;    }&#10;&#10;    private void backtrack2(int[][] lab, int x, int y, int fx, int fy) {&#10;        if (!esValido(lab, x, y) || visitado[x][y]) return;&#10;        visitado[x][y] = true;&#10;        rutaActual.add(new int[]{x, y});&#10;        if (x == fx &amp;&amp; y == fy) {&#10;            if (mejorRuta.isEmpty() || rutaActual.size() &lt; mejorRuta.size()) {&#10;                mejorRuta = new ArrayList&lt;&gt;(rutaActual);&#10;            }&#10;        } else {&#10;            for (int i = 0; i &lt; 2; i++) {&#10;                backtrack2(lab, x + dx2[i], y + dy2[i], fx, fy);&#10;            }&#10;        }&#10;        rutaActual.remove(rutaActual.size() - 1);&#10;        visitado[x][y] = false;&#10;    }&#10;&#10;    public List&lt;int[]&gt; resolver4Direcciones(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        backtrack4(laberinto, fila, col, finFila, finCol);&#10;        return mejorRuta;&#10;    }&#10;&#10;    private void backtrack4(int[][] lab, int x, int y, int fx, int fy) {&#10;        if (!esValido(lab, x, y) || visitado[x][y]) return;&#10;        visitado[x][y] = true;&#10;        rutaActual.add(new int[]{x, y});&#10;        if (x == fx &amp;&amp; y == fy) {&#10;            if (mejorRuta.isEmpty() || rutaActual.size() &lt; mejorRuta.size()) {&#10;                mejorRuta = new ArrayList&lt;&gt;(rutaActual);&#10;            }&#10;        } else {&#10;            for (int i = 0; i &lt; 4; i++) {&#10;                backtrack4(lab, x + dx4[i], y + dy4[i], fx, fy);&#10;            }&#10;        }&#10;        rutaActual.remove(rutaActual.size() - 1);&#10;        visitado[x][y] = false;&#10;    }&#10;&#10;    public List&lt;int[]&gt; resolverBacktracking(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        int maxLargo = laberinto.length * laberinto[0].length + 1;&#10;        backtrackCompletoPodado(laberinto, fila, col, finFila, finCol, new ArrayList&lt;&gt;(), maxLargo);&#10;        return mejorRuta;&#10;    }&#10;&#10;    private void backtrackCompletoPodado(int[][] lab, int x, int y, int fx, int fy, List&lt;int[]&gt; camino, int maxLargo) {&#10;        if (!esValido(lab, x, y) || visitado[x][y]) return;&#10;        if (camino.size() &gt;= maxLargo) return; // Poda: si ya es más largo que el mejor, no seguir&#10;        visitado[x][y] = true;&#10;        camino.add(new int[]{x, y});&#10;        if (x == fx &amp;&amp; y == fy) {&#10;            if (mejorRuta.isEmpty() || camino.size() &lt; mejorRuta.size()) {&#10;                mejorRuta = new ArrayList&lt;&gt;(camino);&#10;                // Actualiza el máximo permitido para podar ramas más largas&#10;                maxLargo = mejorRuta.size();&#10;            }&#10;        } else {&#10;            for (int i = 0; i &lt; 4; i++) {&#10;                backtrackCompletoPodado(lab, x + dx4[i], y + dy4[i], fx, fy, camino, maxLargo);&#10;            }&#10;        }&#10;        camino.remove(camino.size() - 1);&#10;        visitado[x][y] = false;&#10;    }&#10;&#10;    public List&lt;int[]&gt; resolverBacktrackingConMemo(int[][] laberinto, int fila, int col, int finFila, int finCol) {&#10;        inicializar(laberinto);&#10;        memo.clear();&#10;        backtrackConMemo(laberinto, fila, col, finFila, finCol, new ArrayList&lt;&gt;());&#10;        return mejorRuta;&#10;    }&#10;&#10;    private boolean backtrackConMemo(int[][] lab, int x, int y, int fx, int fy, List&lt;int[]&gt; camino) {&#10;        String key = x + &quot;,&quot; + y;&#10;        if (memo.containsKey(key)) return memo.get(key);&#10;        if (!esValido(lab, x, y) || visitado[x][y]) return false;&#10;&#10;        visitado[x][y] = true;&#10;        camino.add(new int[]{x, y});&#10;&#10;        boolean found = false;&#10;        if (x == fx &amp;&amp; y == fy) {&#10;            mejorRuta = new ArrayList&lt;&gt;(camino);&#10;            found = true;&#10;        } else {&#10;            for (int i = 0; i &lt; 4; i++) {&#10;                if (backtrackConMemo(lab, x + dx4[i], y + dy4[i], fx, fy, camino)) {&#10;                    found = true;&#10;                }&#10;            }&#10;        }&#10;&#10;        visitado[x][y] = false;&#10;        camino.remove(camino.size() - 1);&#10;        memo.put(key, found);&#10;        return found;&#10;    }&#10;&#10;    private boolean esValido(int[][] lab, int x, int y) {&#10;        return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; lab.length &amp;&amp; y &lt; lab[0].length &amp;&amp; lab[x][y] == 1;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vista/ControlPanel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vista/ControlPanel.java" />
              <option name="originalContent" value="package vista;&#10;&#10;import javax.swing.*;&#10;import javax.swing.border.TitledBorder;&#10;import java.awt.*;&#10;import java.awt.event.ActionListener;&#10;&#10;/**&#10; * Panel que contiene todos los controles de la aplicación: configuración del&#10; * tamaño, selección de algoritmo, botones de acción y área de resultados.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; * Panel que contiene todos los controles de la aplicación: configuración del tamaño,&#10; * selección de algoritmo, botón para resolver y área de resultados.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.0&#10; */&#10;public class ControlPanel extends JPanel {&#10;    private JComboBox&lt;String&gt; algorithmSelector;&#10;    private JTextArea resultsArea;&#10;    private JTextField rowsField;&#10;    private JTextField colsField;&#10;    private JButton generateButton;&#10;&#10;    private JButton solveButton;&#10;    private JButton showFullPathButton;&#10;    private JButton stepByStepButton;&#10;&#10;    /**&#10;     * Construye el panel de control, inicializando y organizando todos&#10;     * sus componentes de interfaz.&#10;     */&#10;    public ControlPanel() {&#10;        // Configuración del layout principal del panel&#10;        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));&#10;        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));&#10;        setPreferredSize(new Dimension(250, 0)); // Un poco más ancho para el texto de los botones&#10;&#10;        // --- Panel de configuración ---&#10;        JPanel configPanel = new JPanel(new GridLayout(0, 2, 5, 5));&#10;        configPanel.setBorder(new TitledBorder(&quot;Configuración&quot;));&#10;&#10;        rowsField = new JTextField(&quot;8&quot;);&#10;        colsField = new JTextField(&quot;8&quot;);&#10;        generateButton = new JButton(&quot;Generar/Limpiar&quot;);&#10;&#10;        configPanel.add(new JLabel(&quot;Filas:&quot;));&#10;        configPanel.add(rowsField);&#10;        configPanel.add(new JLabel(&quot;Columnas:&quot;));&#10;        configPanel.add(colsField);&#10;        configPanel.add(generateButton);&#10;        configPanel.add(new JLabel()); // Espacio vacío para alinear&#10;        add(configPanel);&#10;&#10;        add(Box.createRigidArea(new Dimension(0, 20)));&#10;&#10;        // --- Panel de selección de algoritmo y acciones ---&#10;        JPanel algoPanel = new JPanel(new BorderLayout(5, 5));&#10;        algoPanel.setBorder(new TitledBorder(&quot;Algoritmo y Acciones&quot;));&#10;        String[] algorithms = {&quot;BFS&quot;, &quot;DFS&quot;, &quot;Recursivo (2 dir)&quot;, &quot;Recursivo (4 dir)&quot;, &quot;Backtracking&quot;};&#10;        algorithmSelector = new JComboBox&lt;&gt;(algorithms);&#10;        algoPanel.add(algorithmSelector, BorderLayout.NORTH);&#10;&#10;        // --- Panel para agrupar los tres botones de acción ---&#10;        JPanel actionButtonsPanel = new JPanel(new GridLayout(0, 1, 5, 5)); // Layout para apilar botones&#10;        solveButton = new JButton(&quot;¡Resolver!&quot;); // Botón original&#10;        showFullPathButton = new JButton(&quot;Mostrar Camino Completo&quot;);&#10;        stepByStepButton = new JButton(&quot;Resolver Paso a Paso&quot;);&#10;&#10;        actionButtonsPanel.add(solveButton);&#10;        actionButtonsPanel.add(showFullPathButton);&#10;        actionButtonsPanel.add(stepByStepButton);&#10;&#10;        algoPanel.add(actionButtonsPanel, BorderLayout.CENTER); // Se añaden al centro&#10;&#10;        add(algoPanel);&#10;&#10;        add(Box.createRigidArea(new Dimension(0, 20)));&#10;&#10;        // --- Panel de resultados ---&#10;        JPanel resultsPanel = new JPanel(new BorderLayout());&#10;        resultsPanel.setBorder(new TitledBorder(&quot;Resultados&quot;));&#10;        resultsArea = new JTextArea(10, 15);&#10;        resultsArea.setEditable(false);&#10;        resultsPanel.add(new JScrollPane(resultsArea));&#10;        add(resultsPanel);&#10;    }&#10;&#10;    // --- Métodos públicos para que otros (la Vista o el Controlador) interactúen con este panel ---&#10;&#10;    /**&#10;     * Obtiene el número de filas introducido por el usuario.&#10;     *&#10;     * @return El número de filas como un entero. Devuelve 20 si la entrada es inválida.&#10;     * @return El número de filas como un entero.&#10;     */&#10;    public int getRows() {&#10;        try {&#10;            return Integer.parseInt(rowsField.getText());&#10;        } catch (NumberFormatException e) {&#10;            return 20; // Valor por defecto si la entrada es inválida&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el número de columnas introducido por el usuario.&#10;     *&#10;     * @return El número de columnas como un entero. Devuelve 20 si la entrada es inválida.&#10;     * @return El número de columnas como un entero.&#10;     */&#10;    public int getCols() {&#10;        try {&#10;            return Integer.parseInt(colsField.getText());&#10;        } catch (NumberFormatException e) {&#10;            return 20; // Valor por defecto&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el nombre del algoritmo seleccionado por el usuario en el JComboBox.&#10;     *&#10;     * Obtiene el nombre del algoritmo seleccionado por el usuario.&#10;     * @return El algoritmo seleccionado como un String.&#10;     */&#10;    public String getSelectedAlgorithm() {&#10;        return (String) algorithmSelector.getSelectedItem();&#10;    }&#10;&#10;    /**&#10;     * Establece el texto que se mostrará en el área de resultados.&#10;     *&#10;     * @param text El texto a mostrar.&#10;     */&#10;    public void setResultsText(String text) {&#10;        resultsArea.setText(text);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Generar/Limpiar&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar cuando se presiona el botón.&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addGenerateListener(ActionListener listener) {&#10;        generateButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;¡Resolver!&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addSolveListener(ActionListener listener) {&#10;        solveButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Mostrar Camino Completo&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addShowFullPathListener(ActionListener listener) {&#10;        showFullPathButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Resolver Paso a Paso&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addStepByStepListener(ActionListener listener) {&#10;        stepByStepButton.addActionListener(listener);&#10;    }&#10;}" />
              <option name="updatedContent" value="package vista;&#10;&#10;import javax.swing.*;&#10;import javax.swing.border.TitledBorder;&#10;import java.awt.*;&#10;import java.awt.event.ActionListener;&#10;&#10;/**&#10; * Panel que contiene todos los controles de la aplicación: configuración del&#10; * tamaño, selección de algoritmo, botones de acción y área de resultados.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; * Panel que contiene todos los controles de la aplicación: configuración del tamaño,&#10; * selección de algoritmo, botón para resolver y área de resultados.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.0&#10; */&#10;public class ControlPanel extends JPanel {&#10;    private JComboBox&lt;String&gt; algorithmSelector;&#10;    private JTextArea resultsArea;&#10;    private JTextField rowsField;&#10;    private JTextField colsField;&#10;    private JButton generateButton;&#10;&#10;    private JButton solveButton;&#10;    private JButton showFullPathButton;&#10;    private JButton stepByStepButton;&#10;    private JButton clearAllButton;&#10;&#10;    /**&#10;     * Construye el panel de control, inicializando y organizando todos&#10;     * sus componentes de interfaz.&#10;     */&#10;    public ControlPanel() {&#10;        // Configuración del layout principal del panel&#10;        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));&#10;        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));&#10;        setPreferredSize(new Dimension(250, 0)); // Un poco más ancho para el texto de los botones&#10;&#10;        // --- Panel de configuración ---&#10;        JPanel configPanel = new JPanel(new GridLayout(0, 2, 5, 5));&#10;        configPanel.setBorder(new TitledBorder(&quot;Configuración&quot;));&#10;&#10;        rowsField = new JTextField(&quot;8&quot;);&#10;        colsField = new JTextField(&quot;8&quot;);&#10;        generateButton = new JButton(&quot;Generar/Limpiar&quot;);&#10;&#10;        configPanel.add(new JLabel(&quot;Filas:&quot;));&#10;        configPanel.add(rowsField);&#10;        configPanel.add(new JLabel(&quot;Columnas:&quot;));&#10;        configPanel.add(colsField);&#10;        configPanel.add(generateButton);&#10;        configPanel.add(new JLabel()); // Espacio vacío para alinear&#10;        add(configPanel);&#10;&#10;        add(Box.createRigidArea(new Dimension(0, 20)));&#10;&#10;        // --- Panel de selección de algoritmo y acciones ---&#10;        JPanel algoPanel = new JPanel(new BorderLayout(5, 5));&#10;        algoPanel.setBorder(new TitledBorder(&quot;Algoritmo y Acciones&quot;));&#10;        String[] algorithms = {&quot;BFS&quot;, &quot;DFS&quot;, &quot;Recursivo (2 dir)&quot;, &quot;Recursivo (4 dir)&quot;, &quot;Backtracking&quot;};&#10;        algorithmSelector = new JComboBox&lt;&gt;(algorithms);&#10;        algoPanel.add(algorithmSelector, BorderLayout.NORTH);&#10;&#10;        // --- Panel para agrupar los tres botones de acción ---&#10;        JPanel actionButtonsPanel = new JPanel(new GridLayout(0, 1, 5, 5)); // Layout para apilar botones&#10;        solveButton = new JButton(&quot;¡Resolver!&quot;); // Botón original&#10;        showFullPathButton = new JButton(&quot;Mostrar Camino Completo&quot;);&#10;        stepByStepButton = new JButton(&quot;Resolver Paso a Paso&quot;);&#10;        clearAllButton = new JButton(&quot;Borrar Todo&quot;);&#10;&#10;        actionButtonsPanel.add(solveButton);&#10;        actionButtonsPanel.add(showFullPathButton);&#10;        actionButtonsPanel.add(stepByStepButton);&#10;        actionButtonsPanel.add(clearAllButton);&#10;&#10;        algoPanel.add(actionButtonsPanel, BorderLayout.CENTER); // Se añaden al centro&#10;&#10;        add(algoPanel);&#10;&#10;        add(Box.createRigidArea(new Dimension(0, 20)));&#10;&#10;        // --- Panel de resultados ---&#10;        JPanel resultsPanel = new JPanel(new BorderLayout());&#10;        resultsPanel.setBorder(new TitledBorder(&quot;Resultados&quot;));&#10;        resultsArea = new JTextArea(10, 15);&#10;        resultsArea.setEditable(false);&#10;        resultsPanel.add(new JScrollPane(resultsArea));&#10;        add(resultsPanel);&#10;    }&#10;&#10;    // --- Métodos públicos para que otros (la Vista o el Controlador) interactúen con este panel ---&#10;&#10;    /**&#10;     * Obtiene el número de filas introducido por el usuario.&#10;     *&#10;     * @return El número de filas como un entero. Devuelve 20 si la entrada es inválida.&#10;     * @return El número de filas como un entero.&#10;     */&#10;    public int getRows() {&#10;        try {&#10;            return Integer.parseInt(rowsField.getText());&#10;        } catch (NumberFormatException e) {&#10;            return 20; // Valor por defecto si la entrada es inválida&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el número de columnas introducido por el usuario.&#10;     *&#10;     * @return El número de columnas como un entero. Devuelve 20 si la entrada es inválida.&#10;     * @return El número de columnas como un entero.&#10;     */&#10;    public int getCols() {&#10;        try {&#10;            return Integer.parseInt(colsField.getText());&#10;        } catch (NumberFormatException e) {&#10;            return 20; // Valor por defecto&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el nombre del algoritmo seleccionado por el usuario en el JComboBox.&#10;     *&#10;     * Obtiene el nombre del algoritmo seleccionado por el usuario.&#10;     * @return El algoritmo seleccionado como un String.&#10;     */&#10;    public String getSelectedAlgorithm() {&#10;        return (String) algorithmSelector.getSelectedItem();&#10;    }&#10;&#10;    /**&#10;     * Establece el texto que se mostrará en el área de resultados.&#10;     *&#10;     * @param text El texto a mostrar.&#10;     */&#10;    public void setResultsText(String text) {&#10;        resultsArea.setText(text);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Generar/Limpiar&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar cuando se presiona el botón.&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addGenerateListener(ActionListener listener) {&#10;        generateButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;¡Resolver!&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addSolveListener(ActionListener listener) {&#10;        solveButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Mostrar Camino Completo&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addShowFullPathListener(ActionListener listener) {&#10;        showFullPathButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Resolver Paso a Paso&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addStepByStepListener(ActionListener listener) {&#10;        stepByStepButton.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el botón &quot;Borrar Todo&quot;.&#10;     *&#10;     * @param listener El ActionListener a ejecutar.&#10;     */&#10;    public void addClearAllListener(ActionListener listener) {&#10;        clearAllButton.addActionListener(listener);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vista/MazePanel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vista/MazePanel.java" />
              <option name="originalContent" value="package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.MouseAdapter;&#10;import java.awt.event.MouseEvent;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Panel que dibuja el laberinto, incluyendo celdas, muros, puntos de&#10; * inicio/fin y la ruta de la solución. También gestiona la interacción&#10; * del usuario con el ratón y las diferentes formas de visualización.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; * Panel que se encarga de dibujar el laberinto, incluyendo celdas, muros,&#10; * puntos de inicio/fin y la ruta de la solución. También gestiona la&#10; * interacción del usuario con el ratón.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.0&#10; */&#10;public class MazePanel extends JPanel {&#10;    private int rows;&#10;    private int cols;&#10;    private int[][] mazeData; // 1 para transitable, 0 para muro&#10;    private Point startPoint;&#10;    private Point endPoint;&#10;&#10;    // --- Atributos para la visualización avanzada ---&#10;    private List&lt;int[]&gt; visitedNodes; // Nodos visitados por el algoritmo (gris)&#10;    private List&lt;int[]&gt; finalPath;    // El camino correcto final (azul)&#10;    private Timer animationTimer;     // Timer para la animación paso a paso&#10;&#10;    /** El tamaño en píxeles de cada celda del laberinto. */&#10;    private final int CELL_SIZE = 25;&#10;&#10;    /**&#10;     * Construye el panel del laberinto con un tamaño inicial.&#10;     *&#10;     * @param rows El número inicial de filas.&#10;     * @param cols El número inicial de columnas.&#10;     */&#10;    public MazePanel(int rows, int cols) {&#10;        this.rows = rows;&#10;        this.cols = cols;&#10;        this.mazeData = new int[rows][cols];&#10;        this.visitedNodes = new ArrayList&lt;&gt;();&#10;        this.finalPath = new ArrayList&lt;&gt;();&#10;&#10;        clearMaze(); // Limpia y establece todo como transitable&#10;&#10;        setPreferredSize(new Dimension(cols * CELL_SIZE, rows * CELL_SIZE));&#10;        addMouseListeners();&#10;    }&#10;&#10;    /**&#10;     * Añade los listeners del ratón para permitir la interacción del usuario&#10;     * con el laberinto (dibujar muros, seleccionar inicio/fin).&#10;     */&#10;    private void addMouseListeners() {&#10;        addMouseListener(new MouseAdapter() {&#10;            @Override&#10;            public void mousePressed(MouseEvent e) {&#10;                int col = e.getX() / CELL_SIZE;&#10;                int row = e.getY() / CELL_SIZE;&#10;&#10;                if (row &gt;= rows || col &gt;= cols) return; // Fuera de los límites&#10;&#10;                // Lógica de Clic: Se comprueba la acción más específica primero.&#10;                if (e.isShiftDown() &amp;&amp; SwingUtilities.isLeftMouseButton(e)) {&#10;                    endPoint = new Point(col, row);&#10;                } else if (SwingUtilities.isRightMouseButton(e)) {&#10;                    startPoint = new Point(col, row);&#10;                } else if (SwingUtilities.isLeftMouseButton(e)) {&#10;                    mazeData[row][col] = (mazeData[row][col] == 1) ? 0 : 1;&#10;                } else if (SwingUtilities.isMiddleMouseButton(e)) {&#10;                    endPoint = new Point(col, row);&#10;                }&#10;                repaint(); // Vuelve a dibujar el panel para reflejar los cambios&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Dibuja todos los componentes del laberinto en capas.&#10;     * El orden es importante para la correcta visualización.&#10;     * Dibuja todos los componentes del laberinto: celdas, muros, cuadrícula,&#10;     * ruta de solución y puntos de inicio/fin.&#10;     *&#10;     * @param g el contexto gráfico en el que se va a dibujar.&#10;     */&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        Graphics2D g2d = (Graphics2D) g;&#10;&#10;        // 1. Dibuja las celdas base (muros y caminos)&#10;        for (int row = 0; row &lt; rows; row++) {&#10;            for (int col = 0; col &lt; cols; col++) {&#10;                g2d.setColor(mazeData[row][col] == 0 ? Color.BLACK : Color.WHITE);&#10;                g2d.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 2. Dibuja los nodos visitados (en gris)&#10;        g2d.setColor(Color.LIGHT_GRAY);&#10;        for (int[] node : visitedNodes) {&#10;            g2d.fillRect(node[1] * CELL_SIZE, node[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;        }&#10;&#10;        // 3. Dibuja el camino final (en azul) sobre los nodos visitados&#10;        g2d.setColor(new Color(66, 135, 245)); // Un azul claro&#10;        for (int[] step : finalPath) {&#10;            g2d.fillRect(step[1] * CELL_SIZE, step[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;        }&#10;&#10;        // 4. Dibuja la cuadrícula&#10;        g2d.setColor(Color.GRAY);&#10;        for (int row = 0; row &lt; rows; row++) {&#10;            for (int col = 0; col &lt; cols; col++) {&#10;                g2d.drawRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 5. Dibuja los puntos de inicio y fin encima de todo&#10;        if (startPoint != null) {&#10;            g2d.setColor(Color.GREEN);&#10;            g2d.fillRect(startPoint.x * CELL_SIZE, startPoint.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.drawString(&quot;A&quot;, startPoint.x * CELL_SIZE + 8, startPoint.y * CELL_SIZE + 18);&#10;        }&#10;        if (endPoint != null) {&#10;            g2d.setColor(Color.RED);&#10;            g2d.fillRect(endPoint.x * CELL_SIZE, endPoint.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            g2d.setColor(Color.WHITE);&#10;            g2d.drawString(&quot;B&quot;, endPoint.x * CELL_SIZE + 8, endPoint.y * CELL_SIZE + 18);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Restablece el laberinto a su estado inicial: todas las celdas transitables&#10;     * y sin puntos de inicio, fin o ruta.&#10;     */&#10;    public void clearMaze() {&#10;        for (int i = 0; i &lt; rows; i++) {&#10;            for (int j = 0; j &lt; cols; j++) {&#10;                mazeData[i][j] = 1; // Todo transitable&#10;            }&#10;        }&#10;        startPoint = null;&#10;        endPoint = null;&#10;        clearVisuals();&#10;    }&#10;&#10;    /**&#10;     * Limpia solo los elementos visuales de la solución (caminos y visitados)&#10;     * y detiene cualquier animación en curso.&#10;     */&#10;    public void clearVisuals() {&#10;        if (animationTimer != null &amp;&amp; animationTimer.isRunning()) {&#10;            animationTimer.stop();&#10;        }&#10;        visitedNodes.clear();&#10;        finalPath.clear();&#10;        repaint();&#10;    }&#10;&#10;    // --- NUEVOS MÉTODOS PÚBLICOS PARA EL CONTROLADOR ---&#10;&#10;    /**&#10;     * Dibuja instantáneamente solo la ruta de la solución final.&#10;     * Usado por el botón &quot;¡Resolver!&quot;.&#10;     * @param path La lista de coordenadas de la ruta final.&#10;     */&#10;    public void drawSimplePath(List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Establece la ruta de la solución para ser dibujada.&#10;     * @param path una lista de coordenadas [fila, columna].&#10;     */&#10;    public void setPath(List&lt;int[]&gt; path) {&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        } else {&#10;            this.finalPath.clear();&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Dibuja instantáneamente todos los nodos visitados y la ruta final.&#10;     * Usado por el botón &quot;Mostrar Camino Completo&quot;.&#10;     * @param visited La lista de todos los nodos explorados por el algoritmo.&#10;     * @param path La lista de coordenadas de la ruta final.&#10;     */&#10;    public void drawFullPath(List&lt;int[]&gt; visited, List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (visited != null) {&#10;            this.visitedNodes = new ArrayList&lt;&gt;(visited);&#10;        }&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Limpia cualquier ruta previamente dibujada en el panel.&#10;     */&#10;    public void clearPath() {&#10;        this.finalPath.clear();&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Inicia una animación paso a paso de la ruta de la solución.&#10;     * Usado por el botón &quot;Resolver Paso a Paso&quot;.&#10;     * @param path La lista de coordenadas de la ruta final para animar.&#10;     */&#10;    public void startStepByStepAnimation(List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (path == null || path.isEmpty()) return;&#10;&#10;        final List&lt;int[]&gt; pathToAnimate = new ArrayList&lt;&gt;(path);&#10;        finalPath.clear();&#10;&#10;        animationTimer = new Timer(50, e -&gt; {&#10;            if (finalPath.size() &lt; pathToAnimate.size()) {&#10;                finalPath.add(pathToAnimate.get(finalPath.size()));&#10;                repaint();&#10;            } else {&#10;                ((Timer) e.getSource()).stop();&#10;            }&#10;        });&#10;        animationTimer.start();&#10;    }&#10;&#10;&#10;    /**&#10;     * Actualiza los datos del laberinto y redibuja el panel.&#10;     * @param mazeData una matriz de enteros que representa el nuevo laberinto.&#10;     */&#10;    public void setMazeData(int[][] mazeData) {&#10;        if (mazeData == null || mazeData.length == 0) return;&#10;        this.rows = mazeData.length;&#10;        this.cols = mazeData[0].length;&#10;        this.mazeData = mazeData;&#10;        setPreferredSize(new Dimension(cols * CELL_SIZE, rows * CELL_SIZE));&#10;        revalidate();&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Obtiene la representación interna del laberinto.&#10;     * @return Una matriz de enteros donde 1 es transitable y 0 es un muro.&#10;     */&#10;    public int[][] getMazeData() { return mazeData; }&#10;&#10;    /**&#10;     * Obtiene el punto de inicio seleccionado por el usuario.&#10;     * @return Un objeto Point con las coordenadas (columna, fila) del inicio.&#10;     */&#10;    public Point getStartPoint() { return startPoint; }&#10;&#10;    /**&#10;     * Obtiene el punto final seleccionado por el usuario.&#10;     * @return Un objeto Point con las coordenadas (columna, fila) del fin.&#10;     */&#10;    public Point getEndPoint() { return endPoint; }&#10;}" />
              <option name="updatedContent" value="package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.MouseAdapter;&#10;import java.awt.event.MouseEvent;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Panel que dibuja el laberinto, incluyendo celdas, muros, puntos de&#10; * inicio/fin y la ruta de la solución. También gestiona la interacción&#10; * del usuario con el ratón y las diferentes formas de visualización.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; * Panel que se encarga de dibujar el laberinto, incluyendo celdas, muros,&#10; * puntos de inicio/fin y la ruta de la solución. También gestiona la&#10; * interacción del usuario con el ratón.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.0&#10; */&#10;public class MazePanel extends JPanel {&#10;    private int rows;&#10;    private int cols;&#10;    private int[][] mazeData; // 1 para transitable, 0 para muro&#10;    private Point startPoint;&#10;    private Point endPoint;&#10;&#10;    // --- Atributos para la visualización avanzada ---&#10;    private List&lt;int[]&gt; visitedNodes; // Nodos visitados por el algoritmo (gris)&#10;    private List&lt;int[]&gt; finalPath;    // El camino correcto final (azul)&#10;    private Timer animationTimer;     // Timer para la animación paso a paso&#10;&#10;    /** El tamaño en píxeles de cada celda del laberinto. */&#10;    private final int CELL_SIZE = 25;&#10;&#10;    /**&#10;     * Construye el panel del laberinto con un tamaño inicial.&#10;     *&#10;     * @param rows El número inicial de filas.&#10;     * @param cols El número inicial de columnas.&#10;     */&#10;    public MazePanel(int rows, int cols) {&#10;        this.rows = rows;&#10;        this.cols = cols;&#10;        this.mazeData = new int[rows][cols];&#10;        this.visitedNodes = new ArrayList&lt;&gt;();&#10;        this.finalPath = new ArrayList&lt;&gt;();&#10;&#10;        clearMaze(); // Limpia y establece todo como transitable&#10;&#10;        setPreferredSize(new Dimension(cols * CELL_SIZE, rows * CELL_SIZE));&#10;        addMouseListeners();&#10;    }&#10;&#10;    /**&#10;     * Añade los listeners del ratón para permitir la interacción del usuario&#10;     * con el laberinto (dibujar muros, seleccionar inicio/fin).&#10;     */&#10;    private void addMouseListeners() {&#10;        addMouseListener(new MouseAdapter() {&#10;            @Override&#10;            public void mousePressed(MouseEvent e) {&#10;                int col = e.getX() / CELL_SIZE;&#10;                int row = e.getY() / CELL_SIZE;&#10;&#10;                if (row &gt;= rows || col &gt;= cols) return; // Fuera de los límites&#10;&#10;                // Solo permitir inicio/fin en celdas transitables&#10;                if (e.isShiftDown() &amp;&amp; SwingUtilities.isLeftMouseButton(e)) {&#10;                    if (mazeData[row][col] == 1) {&#10;                        endPoint = new Point(col, row);&#10;                    } else {&#10;                        JOptionPane.showMessageDialog(MazePanel.this, &quot;El punto de fin debe estar en una celda transitable.&quot;, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    }&#10;                } else if (SwingUtilities.isRightMouseButton(e)) {&#10;                    if (mazeData[row][col] == 1) {&#10;                        startPoint = new Point(col, row);&#10;                    } else {&#10;                        JOptionPane.showMessageDialog(MazePanel.this, &quot;El punto de inicio debe estar en una celda transitable.&quot;, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    }&#10;                } else if (SwingUtilities.isLeftMouseButton(e)) {&#10;                    mazeData[row][col] = (mazeData[row][col] == 1) ? 0 : 1;&#10;                } else if (SwingUtilities.isMiddleMouseButton(e)) {&#10;                    if (mazeData[row][col] == 1) {&#10;                        endPoint = new Point(col, row);&#10;                    } else {&#10;                        JOptionPane.showMessageDialog(MazePanel.this, &quot;El punto de fin debe estar en una celda transitable.&quot;, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;                    }&#10;                }&#10;                repaint(); // Vuelve a dibujar el panel para reflejar los cambios&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Dibuja todos los componentes del laberinto en capas.&#10;     * El orden es importante para la correcta visualización.&#10;     * Dibuja todos los componentes del laberinto: celdas, muros, cuadrícula,&#10;     * ruta de solución y puntos de inicio/fin.&#10;     *&#10;     * @param g el contexto gráfico en el que se va a dibujar.&#10;     */&#10;    @Override&#10;    protected void paintComponent(Graphics g) {&#10;        super.paintComponent(g);&#10;        Graphics2D g2d = (Graphics2D) g;&#10;&#10;        // 1. Dibuja las celdas base (muros y caminos)&#10;        for (int row = 0; row &lt; rows; row++) {&#10;            for (int col = 0; col &lt; cols; col++) {&#10;                g2d.setColor(mazeData[row][col] == 0 ? Color.BLACK : Color.WHITE);&#10;                g2d.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 2. Dibuja los nodos visitados (en gris)&#10;        g2d.setColor(Color.LIGHT_GRAY);&#10;        for (int[] node : visitedNodes) {&#10;            g2d.fillRect(node[1] * CELL_SIZE, node[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;        }&#10;&#10;        // 3. Dibuja el camino final (en azul) sobre los nodos visitados&#10;        g2d.setColor(new Color(66, 135, 245)); // Un azul claro&#10;        for (int[] step : finalPath) {&#10;            g2d.fillRect(step[1] * CELL_SIZE, step[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;        }&#10;&#10;        // 4. Dibuja la cuadrícula&#10;        g2d.setColor(Color.GRAY);&#10;        for (int row = 0; row &lt; rows; row++) {&#10;            for (int col = 0; col &lt; cols; col++) {&#10;                g2d.drawRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            }&#10;        }&#10;&#10;        // 5. Dibuja los puntos de inicio y fin encima de todo&#10;        if (startPoint != null) {&#10;            g2d.setColor(Color.GREEN);&#10;            g2d.fillRect(startPoint.x * CELL_SIZE, startPoint.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            g2d.setColor(Color.BLACK);&#10;            g2d.drawString(&quot;A&quot;, startPoint.x * CELL_SIZE + 8, startPoint.y * CELL_SIZE + 18);&#10;        }&#10;        if (endPoint != null) {&#10;            g2d.setColor(Color.RED);&#10;            g2d.fillRect(endPoint.x * CELL_SIZE, endPoint.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);&#10;            g2d.setColor(Color.WHITE);&#10;            g2d.drawString(&quot;B&quot;, endPoint.x * CELL_SIZE + 8, endPoint.y * CELL_SIZE + 18);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Restablece el laberinto a su estado inicial: todas las celdas transitables&#10;     * y sin puntos de inicio, fin o ruta.&#10;     */&#10;    public void clearMaze() {&#10;        for (int i = 0; i &lt; rows; i++) {&#10;            for (int j = 0; j &lt; cols; j++) {&#10;                mazeData[i][j] = 1; // Todo transitable&#10;            }&#10;        }&#10;        startPoint = null;&#10;        endPoint = null;&#10;        clearVisuals();&#10;    }&#10;&#10;    /**&#10;     * Limpia solo los elementos visuales de la solución (caminos y visitados)&#10;     * y detiene cualquier animación en curso.&#10;     */&#10;    public void clearVisuals() {&#10;        if (animationTimer != null &amp;&amp; animationTimer.isRunning()) {&#10;            animationTimer.stop();&#10;        }&#10;        visitedNodes.clear();&#10;        finalPath.clear();&#10;        repaint();&#10;    }&#10;&#10;    // --- NUEVOS MÉTODOS PÚBLICOS PARA EL CONTROLADOR ---&#10;&#10;    /**&#10;     * Dibuja instantáneamente solo la ruta de la solución final.&#10;     * Usado por el botón &quot;¡Resolver!&quot;.&#10;     * @param path La lista de coordenadas de la ruta final.&#10;     */&#10;    public void drawSimplePath(List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Establece la ruta de la solución para ser dibujada.&#10;     * @param path una lista de coordenadas [fila, columna].&#10;     */&#10;    public void setPath(List&lt;int[]&gt; path) {&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        } else {&#10;            this.finalPath.clear();&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Dibuja instantáneamente todos los nodos visitados y la ruta final.&#10;     * Usado por el botón &quot;Mostrar Camino Completo&quot;.&#10;     * @param visited La lista de todos los nodos explorados por el algoritmo.&#10;     * @param path La lista de coordenadas de la ruta final.&#10;     */&#10;    public void drawFullPath(List&lt;int[]&gt; visited, List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (visited != null) {&#10;            this.visitedNodes = new ArrayList&lt;&gt;(visited);&#10;        }&#10;        if (path != null) {&#10;            this.finalPath = new ArrayList&lt;&gt;(path);&#10;        }&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Limpia cualquier ruta previamente dibujada en el panel.&#10;     */&#10;    public void clearPath() {&#10;        this.finalPath.clear();&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Inicia una animación paso a paso de la ruta de la solución.&#10;     * Usado por el botón &quot;Resolver Paso a Paso&quot;.&#10;     * @param path La lista de coordenadas de la ruta final para animar.&#10;     */&#10;    public void startStepByStepAnimation(List&lt;int[]&gt; path) {&#10;        clearVisuals();&#10;        if (path == null || path.isEmpty()) return;&#10;&#10;        final List&lt;int[]&gt; pathToAnimate = new ArrayList&lt;&gt;(path);&#10;        finalPath.clear();&#10;&#10;        animationTimer = new Timer(50, e -&gt; {&#10;            if (finalPath.size() &lt; pathToAnimate.size()) {&#10;                finalPath.add(pathToAnimate.get(finalPath.size()));&#10;                repaint();&#10;            } else {&#10;                ((Timer) e.getSource()).stop();&#10;            }&#10;        });&#10;        animationTimer.start();&#10;    }&#10;&#10;&#10;    /**&#10;     * Actualiza los datos del laberinto y redibuja el panel.&#10;     * @param mazeData una matriz de enteros que representa el nuevo laberinto.&#10;     */&#10;    public void setMazeData(int[][] mazeData) {&#10;        if (mazeData == null || mazeData.length == 0) return;&#10;        this.rows = mazeData.length;&#10;        this.cols = mazeData[0].length;&#10;        this.mazeData = mazeData;&#10;        setPreferredSize(new Dimension(cols * CELL_SIZE, rows * CELL_SIZE));&#10;        revalidate();&#10;        repaint();&#10;    }&#10;&#10;    /**&#10;     * Obtiene la representación interna del laberinto.&#10;     * @return Una matriz de enteros donde 1 es transitable y 0 es un muro.&#10;     */&#10;    public int[][] getMazeData() { return mazeData; }&#10;&#10;    /**&#10;     * Obtiene el punto de inicio seleccionado por el usuario.&#10;     * @return Un objeto Point con las coordenadas (columna, fila) del inicio.&#10;     */&#10;    public Point getStartPoint() { return startPoint; }&#10;&#10;    /**&#10;     * Obtiene el punto final seleccionado por el usuario.&#10;     * @return Un objeto Point con las coordenadas (columna, fila) del fin.&#10;     */&#10;    public Point getEndPoint() { return endPoint; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vista/MazeView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vista/MazeView.java" />
              <option name="originalContent" value="// /src/main/java/vista/MazeView.java&#10;package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionListener;&#10;import java.util.List;&#10;&#10;/**&#10; * La ventana principal (JFrame) de la aplicación.&#10; * Ensambla el MazePanel (lienzo), el ControlPanel (botones) y la barra de menú.&#10; * Proporciona métodos para que el Controlador interactúe con la vista,&#10; * siguiendo el patrón Modelo-Vista-Controlador (MVC).&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; */&#10;public class MazeView extends JFrame {&#10;&#10;    private MazePanel mazePanel;&#10;    private ControlPanel controlPanel;&#10;&#10;    // --- Atributos para los items del menú ---&#10;    private JMenuItem listResultsMenuItem;&#10;    private JMenuItem showTimesChartMenuItem;&#10;&#10;    /**&#10;     * Construye la ventana principal, inicializando y organizando todos los&#10;     * componentes de la interfaz de usuario.&#10;     */&#10;    public MazeView() {&#10;        setTitle(&quot;Solucionador de Laberintos&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout(10, 10));&#10;        setSize(500, 800);&#10;&#10;        // 1. Crear la barra de menú&#10;        createMenuBar();&#10;&#10;        // 2. Crear instancias de los paneles&#10;        mazePanel = new MazePanel(20, 20);&#10;        controlPanel = new ControlPanel();&#10;&#10;        // 3. Añadirlos a la ventana&#10;        add(mazePanel, BorderLayout.CENTER);&#10;        add(controlPanel, BorderLayout.EAST);&#10;&#10;        pack();&#10;        setLocationRelativeTo(null);&#10;        // NOTA: setVisible(true) es llamado por la clase App, no aquí.&#10;    }&#10;&#10;    /**&#10;     * Crea y configura la barra de menú de la aplicación.&#10;     * Este es un método de ayuda privado para mantener el constructor limpio.&#10;     */&#10;    private void createMenuBar() {&#10;        JMenuBar menuBar = new JMenuBar();&#10;&#10;        JMenu reportsMenu = new JMenu(&quot;Reportes&quot;);&#10;        menuBar.add(reportsMenu);&#10;&#10;        listResultsMenuItem = new JMenuItem(&quot;Listar Historial de Resultados&quot;);&#10;        showTimesChartMenuItem = new JMenuItem(&quot;Mostrar Gráfica de Tiempos&quot;);&#10;&#10;        reportsMenu.add(listResultsMenuItem);&#10;        reportsMenu.add(showTimesChartMenuItem);&#10;&#10;        setJMenuBar(menuBar);&#10;    }&#10;&#10;    // --- MÉTODOS PARA QUE EL CONTROLADOR MUESTRE VENTANAS SECUNDARIAS ---&#10;    // --- Métodos públicos para que el Controlador actualice la vista --&#10;&#10;    /**&#10;     * Crea y muestra una ventana de diálogo modal con la tabla de resultados.&#10;     * Esta acción es invocada por el Controlador.&#10;     */&#10;    public void showResultsTable() {&#10;        ResultsTableView resultsDialog = new ResultsTableView(this);&#10;        resultsDialog.setVisible(true);&#10;    }&#10;&#10;    /**&#10;     * Crea y muestra una ventana de diálogo modal para la gráfica de tiempos.&#10;     * Esta acción es invocada por el Controlador.&#10;     */&#10;    public void showTimesChart() {&#10;        TimesChartView chartDialog = new TimesChartView(this);&#10;        chartDialog.setVisible(true);&#10;    }&#10;&#10;    // --- MÉTODOS PARA QUE EL CONTROLADOR AÑADA LISTENERS ---&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el item de menú &quot;Listar Historial de Resultados&quot;.&#10;     * @param listener El ActionListener a ejecutar, típicamente proporcionado por el Controlador.&#10;     */&#10;    public void addListResultsListener(ActionListener listener) {&#10;        listResultsMenuItem.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el item de menú &quot;Mostrar Gráfica de Tiempos&quot;.&#10;     * @param listener El ActionListener a ejecutar, típicamente proporcionado por el Controlador.&#10;     */&#10;    public void addShowTimesChartListener(ActionListener listener) {&#10;        showTimesChartMenuItem.addActionListener(listener);&#10;    }&#10;&#10;    // --- MÉTODOS DE ACCESO Y UTILIDAD ---&#10;&#10;    /**&#10;     * Devuelve la instancia del panel del laberinto.&#10;     * @return El componente MazePanel.&#10;     */&#10;    public MazePanel getMazePanel() {&#10;        return mazePanel;&#10;    }&#10;&#10;    /**&#10;     * Devuelve la instancia del panel de control.&#10;     * @return El componente ControlPanel.&#10;     */&#10;    public ControlPanel getControlPanel() {&#10;        return controlPanel;&#10;    }&#10;&#10;    /**&#10;     * Muestra un mensaje de error genérico en un diálogo.&#10;     * @param message El mensaje de error a mostrar.&#10;     */&#10;    public void showError(String message) {&#10;        JOptionPane.showMessageDialog(this, message, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * Muestra los resultados de texto en el área de resultados del panel de control.&#10;     * @param results El texto con los resultados a mostrar.&#10;     */&#10;    public void setResults(String results) {&#10;        controlPanel.setResultsText(results);&#10;    }&#10;&#10;    /**&#10;     * Dibuja una ruta simple en el panel del laberinto.&#10;     * Este método delega la llamada al MazePanel.&#10;     * @param path La lista de coordenadas que componen la ruta.&#10;     */&#10;    public void drawPath(List&lt;int[]&gt; path) {&#10;        // Delega la acción al método correspondiente en MazePanel&#10;        mazePanel.drawSimplePath(path);&#10;    }&#10;&#10;    /**&#10;     * Limpia cualquier elemento visual de la solución (rutas, nodos visitados)&#10;     * en el panel del laberinto.&#10;     */&#10;    public void clearPath() {&#10;        // Delega la acción al método de limpieza visual en MazePanel&#10;        mazePanel.clearVisuals();&#10;    }&#10;}" />
              <option name="updatedContent" value="// /src/main/java/vista/MazeView.java&#10;package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ActionListener;&#10;import java.util.List;&#10;&#10;/**&#10; * La ventana principal (JFrame) de la aplicación.&#10; * Ensambla el MazePanel (lienzo), el ControlPanel (botones) y la barra de menú.&#10; * Proporciona métodos para que el Controlador interactúe con la vista,&#10; * siguiendo el patrón Modelo-Vista-Controlador (MVC).&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; */&#10;public class MazeView extends JFrame {&#10;&#10;    private MazePanel mazePanel;&#10;    private ControlPanel controlPanel;&#10;&#10;    // --- Atributos para los items del menú ---&#10;    private JMenuItem listResultsMenuItem;&#10;    private JMenuItem showTimesChartMenuItem;&#10;&#10;    /**&#10;     * Construye la ventana principal, inicializando y organizando todos los&#10;     * componentes de la interfaz de usuario.&#10;     */&#10;    public MazeView() {&#10;        setTitle(&quot;Solucionador de Laberintos&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout(10, 10));&#10;        setSize(500, 800);&#10;&#10;        // 1. Crear la barra de menú&#10;        createMenuBar();&#10;&#10;        // 2. Crear instancias de los paneles&#10;        mazePanel = new MazePanel(8, 8);&#10;        controlPanel = new ControlPanel();&#10;&#10;        // 3. Añadirlos a la ventana&#10;        add(mazePanel, BorderLayout.CENTER);&#10;        add(controlPanel, BorderLayout.EAST);&#10;&#10;        pack();&#10;        setLocationRelativeTo(null);&#10;        // NOTA: setVisible(true) es llamado por la clase App, no aquí.&#10;    }&#10;&#10;    /**&#10;     * Crea y configura la barra de menú de la aplicación.&#10;     * Este es un método de ayuda privado para mantener el constructor limpio.&#10;     */&#10;    private void createMenuBar() {&#10;        JMenuBar menuBar = new JMenuBar();&#10;&#10;        JMenu reportsMenu = new JMenu(&quot;Reportes&quot;);&#10;        menuBar.add(reportsMenu);&#10;&#10;        listResultsMenuItem = new JMenuItem(&quot;Listar Historial de Resultados&quot;);&#10;        showTimesChartMenuItem = new JMenuItem(&quot;Mostrar Gráfica de Tiempos&quot;);&#10;&#10;        reportsMenu.add(listResultsMenuItem);&#10;        reportsMenu.add(showTimesChartMenuItem);&#10;&#10;        setJMenuBar(menuBar);&#10;    }&#10;&#10;    // --- MÉTODOS PARA QUE EL CONTROLADOR MUESTRE VENTANAS SECUNDARIAS ---&#10;    // --- Métodos públicos para que el Controlador actualice la vista --&#10;&#10;    /**&#10;     * Crea y muestra una ventana de diálogo modal con la tabla de resultados.&#10;     * Esta acción es invocada por el Controlador.&#10;     */&#10;    public void showResultsTable() {&#10;        ResultsTableView resultsDialog = new ResultsTableView(this);&#10;        resultsDialog.setVisible(true);&#10;    }&#10;&#10;    /**&#10;     * Crea y muestra una ventana de diálogo modal para la gráfica de tiempos.&#10;     * Esta acción es invocada por el Controlador.&#10;     */&#10;    public void showTimesChart() {&#10;        TimesChartView chartDialog = new TimesChartView(this);&#10;        chartDialog.setVisible(true);&#10;    }&#10;&#10;    // --- MÉTODOS PARA QUE EL CONTROLADOR AÑADA LISTENERS ---&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el item de menú &quot;Listar Historial de Resultados&quot;.&#10;     * @param listener El ActionListener a ejecutar, típicamente proporcionado por el Controlador.&#10;     */&#10;    public void addListResultsListener(ActionListener listener) {&#10;        listResultsMenuItem.addActionListener(listener);&#10;    }&#10;&#10;    /**&#10;     * Añade un listener para el evento de clic en el item de menú &quot;Mostrar Gráfica de Tiempos&quot;.&#10;     * @param listener El ActionListener a ejecutar, típicamente proporcionado por el Controlador.&#10;     */&#10;    public void addShowTimesChartListener(ActionListener listener) {&#10;        showTimesChartMenuItem.addActionListener(listener);&#10;    }&#10;&#10;    // --- MÉTODOS DE ACCESO Y UTILIDAD ---&#10;&#10;    /**&#10;     * Devuelve la instancia del panel del laberinto.&#10;     * @return El componente MazePanel.&#10;     */&#10;    public MazePanel getMazePanel() {&#10;        return mazePanel;&#10;    }&#10;&#10;    /**&#10;     * Devuelve la instancia del panel de control.&#10;     * @return El componente ControlPanel.&#10;     */&#10;    public ControlPanel getControlPanel() {&#10;        return controlPanel;&#10;    }&#10;&#10;    /**&#10;     * Muestra un mensaje de error genérico en un diálogo.&#10;     * @param message El mensaje de error a mostrar.&#10;     */&#10;    public void showError(String message) {&#10;        JOptionPane.showMessageDialog(this, message, &quot;Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;    }&#10;&#10;    /**&#10;     * Muestra los resultados de texto en el área de resultados del panel de control.&#10;     * @param results El texto con los resultados a mostrar.&#10;     */&#10;    public void setResults(String results) {&#10;        controlPanel.setResultsText(results);&#10;    }&#10;&#10;    /**&#10;     * Dibuja una ruta simple en el panel del laberinto.&#10;     * Este método delega la llamada al MazePanel.&#10;     * @param path La lista de coordenadas que componen la ruta.&#10;     */&#10;    public void drawPath(List&lt;int[]&gt; path) {&#10;        // Delega la acción al método correspondiente en MazePanel&#10;        mazePanel.drawSimplePath(path);&#10;    }&#10;&#10;    /**&#10;     * Limpia cualquier elemento visual de la solución (rutas, nodos visitados)&#10;     * en el panel del laberinto.&#10;     */&#10;    public void clearPath() {&#10;        // Delega la acción al método de limpieza visual en MazePanel&#10;        mazePanel.clearVisuals();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vista/TimesChartView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vista/TimesChartView.java" />
              <option name="originalContent" value="// /src/main/java/vista/TimesChartView.java&#10;package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import org.jfree.chart.ChartFactory;&#10;import org.jfree.chart.ChartPanel;&#10;import org.jfree.chart.JFreeChart;&#10;import org.jfree.chart.plot.PlotOrientation;&#10;import org.jfree.data.category.DefaultCategoryDataset;&#10;import java.io.BufferedReader;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Una ventana de diálogo (JDialog) para mostrar la gráfica de comparación de tiempos.&#10; * &lt;p&gt;&#10; * Actualmente, esta clase actúa como un &lt;b&gt;placeholder&lt;/b&gt;, mostrando un mensaje&#10; * de texto. En una futura implementación, podría integrarse con una librería&#10; * de gráficos como JFreeChart para visualizar los datos de rendimiento.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; */&#10;public class TimesChartView extends JDialog {&#10;&#10;    /**&#10;     * Construye la ventana de diálogo para la gráfica de tiempos.&#10;     *&#10;     * @param owner La ventana principal (JFrame) que es dueña de este diálogo,&#10;     *              asegurando que el diálogo se comporte de manera modal.&#10;     */&#10;    public TimesChartView(Frame owner) {&#10;        super(owner, &quot;Gráfica de Tiempos de Ejecución&quot;, true);&#10;        setSize(800, 600);&#10;        setLocationRelativeTo(owner);&#10;&#10;        DefaultCategoryDataset dataset = new DefaultCategoryDataset();&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;resultados_laberinto.csv&quot;))) {&#10;            String header = br.readLine(); // Leer encabezado&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length &gt;= 5) {&#10;                    String timestamp = parts[0].trim();&#10;                    String algoritmo = parts[1].trim();&#10;                    // String pathFound = parts[2].trim(); // No se usa&#10;                    // String pathLength = parts[3].trim(); // No se usa&#10;                    double tiempo = Double.parseDouble(parts[4].trim());&#10;                    dataset.addValue(tiempo, algoritmo, timestamp);&#10;                }&#10;            }&#10;        } catch (IOException | NumberFormatException ex) {&#10;            JLabel errorLabel = new JLabel(&quot;Error al leer el archivo CSV o formato incorrecto.&quot;, SwingConstants.CENTER);&#10;            errorLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;            add(errorLabel, BorderLayout.CENTER);&#10;            return;&#10;        }&#10;&#10;        JFreeChart lineChart = ChartFactory.createLineChart(&#10;                &quot;Comparación de Tiempos de Algoritmos&quot;,&#10;                &quot;Nombre del Laberinto&quot;,&#10;                &quot;Tiempo (ms)&quot;,&#10;                dataset,&#10;                PlotOrientation.VERTICAL,&#10;                true, true, false&#10;        );&#10;        // Personalización de colores y diseño&#10;        lineChart.setBackgroundPaint(Color.WHITE);&#10;        lineChart.getPlot().setBackgroundPaint(new Color(240, 240, 255));&#10;&#10;        ChartPanel chartPanel = new ChartPanel(lineChart);&#10;        setLayout(new BorderLayout());&#10;        add(chartPanel, BorderLayout.CENTER);&#10;    }&#10;}" />
              <option name="updatedContent" value="// /src/main/java/vista/TimesChartView.java&#10;package vista;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import org.jfree.chart.ChartFactory;&#10;import org.jfree.chart.ChartPanel;&#10;import org.jfree.chart.JFreeChart;&#10;import org.jfree.chart.plot.PlotOrientation;&#10;import org.jfree.data.category.DefaultCategoryDataset;&#10;import java.io.BufferedReader;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Una ventana de diálogo (JDialog) para mostrar la gráfica de comparación de tiempos.&#10; * &lt;p&gt;&#10; * Actualmente, esta clase actúa como un &lt;b&gt;placeholder&lt;/b&gt;, mostrando un mensaje&#10; * de texto. En una futura implementación, podría integrarse con una librería&#10; * de gráficos como JFreeChart para visualizar los datos de rendimiento.&#10; *&#10; * @author Israel Orellana&#10; * @version 1.1&#10; */&#10;public class TimesChartView extends JDialog {&#10;&#10;    /**&#10;     * Construye la ventana de diálogo para la gráfica de tiempos.&#10;     *&#10;     * @param owner La ventana principal (JFrame) que es dueña de este diálogo,&#10;     *              asegurando que el diálogo se comporte de manera modal.&#10;     */&#10;    public TimesChartView(Frame owner) {&#10;        super(owner, &quot;Gráfica de Tiempos de Ejecución&quot;, true);&#10;        setSize(800, 600);&#10;        setLocationRelativeTo(owner);&#10;&#10;        DefaultCategoryDataset dataset = new DefaultCategoryDataset();&#10;        boolean tieneDatos = false;&#10;        try (BufferedReader br = new BufferedReader(new FileReader(&quot;resultados_laberinto.csv&quot;))) {&#10;            String header = br.readLine(); // Leer encabezado&#10;            String line;&#10;            while ((line = br.readLine()) != null) {&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length &gt;= 5) {&#10;                    String timestamp = parts[0].trim();&#10;                    String algoritmo = parts[1].trim();&#10;                    double tiempo = Double.parseDouble(parts[4].trim());&#10;                    dataset.addValue(tiempo, algoritmo, timestamp);&#10;                    tieneDatos = true;&#10;                }&#10;            }&#10;        } catch (IOException | NumberFormatException ex) {&#10;            JLabel errorLabel = new JLabel(&quot;Error al leer el archivo CSV o formato incorrecto.&quot;, SwingConstants.CENTER);&#10;            errorLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;            add(errorLabel, BorderLayout.CENTER);&#10;            return;&#10;        }&#10;        if (!tieneDatos) {&#10;            JLabel vacioLabel = new JLabel(&quot;No hay datos de tiempos para mostrar.&quot;, SwingConstants.CENTER);&#10;            vacioLabel.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;            add(vacioLabel, BorderLayout.CENTER);&#10;            return;&#10;        }&#10;        JFreeChart lineChart = ChartFactory.createLineChart(&#10;                &quot;Comparación de Tiempos de Algoritmos&quot;,&#10;                &quot;Timestamp&quot;,&#10;                &quot;Tiempo (ms)&quot;,&#10;                dataset,&#10;                PlotOrientation.VERTICAL,&#10;                true, true, false&#10;        );&#10;        // Personalización de colores y diseño&#10;        lineChart.setBackgroundPaint(Color.WHITE);&#10;        lineChart.getPlot().setBackgroundPaint(new Color(240, 240, 255));&#10;&#10;        ChartPanel chartPanel = new ChartPanel(lineChart);&#10;        setLayout(new BorderLayout());&#10;        add(chartPanel, BorderLayout.CENTER);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>